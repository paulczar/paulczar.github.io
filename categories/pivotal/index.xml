<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pivotal on Paul Czarkowski</title>
    <link>https://tech.paulcz.net/categories/pivotal/</link>
    <description>Recent content in pivotal on Paul Czarkowski</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tech.paulcz.net/categories/pivotal/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring into Kubernetes - Using Kubernetes as a Config Server</title>
      <link>https://tech.paulcz.net/blog/spring-into-kubernetes-config-server/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/spring-into-kubernetes-config-server/</guid>
      <description>In previous installments of Spring into Kubernetes I&amp;rsquo;ve shown you how to build images, deploy applications and write a Helm Chart for Spring applications. In this installment we&amp;rsquo;ll look at Spring Cloud Kubernetes integrations, specifically using Kubernetes Config Maps as a Config Server.
Usually I would use a Pivotal Container Service cluster to demonstrate, but in this demonstration I&amp;rsquo;ll use a local minikube cluster.
Spring Cloud Kubernetes Spring Cloud Kubernetes brings in a ton of integrations with Kubernetes.</description>
      <content>

&lt;p&gt;In previous installments of Spring into Kubernetes I&amp;rsquo;ve shown you how to &lt;a href=&#34;https://tech.paulcz.net/blog/building-spring-docker-images/&#34;&gt;build images&lt;/a&gt;, &lt;a href=&#34;https://tech.paulcz.net/blog/spring-into-kubernetes-part-1/&#34;&gt;deploy applications&lt;/a&gt; and write a &lt;a href=&#34;https://tech.paulcz.net/blog/spring-into-kubernetes-part-2/&#34;&gt;Helm Chart&lt;/a&gt; for Spring applications. In this installment we&amp;rsquo;ll look at &lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-kubernetes&#34;&gt;Spring Cloud Kubernetes&lt;/a&gt; integrations, specifically using Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files&#34;&gt;Config Maps&lt;/a&gt; as a Config Server.&lt;/p&gt;

&lt;p&gt;Usually I would use a &lt;a href=&#34;https://pivotal.io/platform/pivotal-container-service&#34;&gt;Pivotal Container Service&lt;/a&gt; cluster to demonstrate, but in this demonstration I&amp;rsquo;ll use a local &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube/&#34;&gt;minikube&lt;/a&gt; cluster.&lt;/p&gt;

&lt;h2 id=&#34;spring-cloud-kubernetes&#34;&gt;Spring Cloud Kubernetes&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-kubernetes&#34;&gt;Spring Cloud Kubernetes&lt;/a&gt; brings in a ton of integrations with Kubernetes. This demonstration will focus just on the ability to integrate Kubernetes as a &lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-kubernetes#kubernetes-propertysource-implementations&#34;&gt;configuration server&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Minimal changes are needed to your applications, you need to simply add the following classes to your &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-kubernetes-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need to enable it in your &lt;code&gt;bootstrap.yaml&lt;/code&gt; (or &lt;code&gt;.properties&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring.cloud.kubernetes.config.enabled: true
spring.cloud.kubernetes.reload.enabled: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll need to &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube/&#34;&gt;install minikube&lt;/a&gt; by following the instructions provided for your Operating System. You&amp;rsquo;ll also need &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/&#34;&gt;kubectl&lt;/a&gt; so that you can give instructions to Kubernetes.&lt;/p&gt;

&lt;p&gt;Start Minikube:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ minikube start
üòÑ  minikube v0.34.1 on linux (amd64)
üí°  Tip: Use &#39;minikube start -p &amp;lt;name&amp;gt;&#39; to create a new cluster, or &#39;minikube delete&#39; to delete this one.
üîÑ  Restarting existing virtualbox VM for &amp;quot;minikube&amp;quot; ...
‚åõ  Waiting for SSH access ...
üì∂  &amp;quot;minikube&amp;quot; IP address is 192.168.99.103
üê≥  Configuring Docker as the container runtime ...
‚ú®  Preparing Kubernetes environment ...
üöú  Pulling images required by Kubernetes v1.13.3 ...
üîÑ  Relaunching Kubernetes v1.13.3 using kubeadm ...
‚åõ  Waiting for kube-proxy to come back up ...
ü§î  Verifying component health ......
üíó  kubectl is now configured to use &amp;quot;minikube&amp;quot;
üèÑ  Done! Thank you for using minikube!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensure that you can communicate with minikube:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl get nodes
NAME       STATUS   ROLES    AGE   VERSION
minikube   Ready    master   36h   v1.13.3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;deploy-spring-hello-world&#34;&gt;Deploy Spring Hello World&lt;/h2&gt;

&lt;p&gt;The source for this demo can be found at &lt;a href=&#34;https://github.com/paulczar/spring-helloworld&#34;&gt;paulczar/spring-hello&lt;/a&gt; on github. Of importance it will respond to a web request with the contents of the application property &lt;code&gt;message&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Deploy the example Hello World application and expose it via a service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl run hello --image=paulczar/spring-hello:k8s001 --port=8080
deployment.apps/hello created

$ kubectl expose deployment hello --type=LoadBalancer --port 80 --target-port 8080
service/hello exposed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;code&gt;minikube service list&lt;/code&gt; to get a list of services and the URLs for those services. This helps make up for the lack of LoadBalancer support in minikube:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ minikube service list
|-------------|------------|-----------------------------|
|  NAMESPACE  |    NAME    |             URL             |
|-------------|------------|-----------------------------|
| default     | hello      | http://192.168.99.103:30871 |
| default     | kubernetes | No node port                |
| kube-system | kube-dns   | No node port                |
|-------------|------------|-----------------------------|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the URL provided for the &lt;code&gt;hello&lt;/code&gt; service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://192.168.99.103:30871
hello development
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our application is running and responding with &lt;code&gt;hello development&lt;/code&gt;. This is the default value for &lt;code&gt;message&lt;/code&gt; in the &lt;code&gt;development&lt;/code&gt; spring profile.&lt;/p&gt;

&lt;h2 id=&#34;configure-kubernetes-support-for-spring-hello-world&#34;&gt;Configure Kubernetes support for Spring Hello World&lt;/h2&gt;

&lt;p&gt;If you have &lt;code&gt;rbac&lt;/code&gt; enabled in your cluster (which you should, we&amp;rsquo;re not animals) the service account your application is running and will be unable to view kubernetes resources. You can see these errors in the pod&amp;rsquo;s logs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;k logs deployment/hello
2019-03-01 16:13:02.629  WARN 1 --- [           main] o.s.cloud.kubernetes.StandardPodUtils    : Failed to get pod with name:[hello-bb9cf575d-rqt6n]. You should look into this if things aren&#39;t working as you expect. Are you missing serviceaccount permissions?

io.fabric8.kubernetes.client.KubernetesClientException: Failure executing: GET at: https://10.96.0.1/api/v1/namespaces/default/pods/hello-bb9cf575d-rqt6n. Message: Forbidden!Configured service account doesn&#39;t have access. Service account may have been revoked. pods &amp;quot;hello-bb9cf575d-rqt6n&amp;quot; is forbidden: User &amp;quot;system:serviceaccount:default:default&amp;quot; cannot get resource &amp;quot;pods&amp;quot; in API group &amp;quot;&amp;quot; in the namespace &amp;quot;default&amp;quot;.
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could create a new service user and give it the appropriate permissions, or you could give permissions to the default service account. Do the latter using a kubernetes manifest found &lt;a href=&#34;https://raw.githubusercontent.com/paulczar/spring-helloworld/master/deploy/rbac.yaml&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Update the &lt;code&gt;rolebinding&lt;/code&gt; for the default user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/paulczar/spring-helloworld/master/deploy/rbac.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delete the current pod to have the kubernetes deployment start a new one which should now have permissions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl get pods
NAME                    READY   STATUS    RESTARTS   AGE
hello-bb9cf575d-rqt6n   1/1     Running   0          12m

$ kubectl delete pod hello-bb9cf575d-rqt6n
pod &amp;quot;hello-bb9cf575d-rqt6n&amp;quot; deleted

$ kubectl get pods
NAME                    READY   STATUS    RESTARTS   AGE
hello-bb9cf575d-8mwxq   1/1     Running   0          21s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look at the logs you&amp;rsquo;ll see the error has disappeared and you can see it is looking for a &lt;code&gt;configmap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl logs deployment/hello
2019-03-01 16:26:33.080 DEBUG 1 --- [           main] o.s.cloud.kubernetes.config.ConfigUtils  : Config Map name has not been set, taking it from property/env spring.application.name (default=application)
2019-03-01 16:26:33.080 DEBUG 1 --- [           main] o.s.cloud.kubernetes.config.ConfigUtils  : Config Map namespace has not been set, taking it from client (ns=default)
2019-03-01 16:26:33.188  INFO 1 --- [           main] b.c.PropertySourceBootstrapConfiguration : Located property source: CompositePropertySource {name=&#39;composite-configmap&#39;, propertySources=[ConfigMapPropertySource@872306601 {name=&#39;configmap.hello.default&#39;, properties={}}]}

Since you haven&#39;t yet created a `configmap` the response from the application should still be the default:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;console
$ curl &lt;a href=&#34;http://192.168.99.103:30871&#34;&gt;http://192.168.99.103:30871&lt;/a&gt;
hello development&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Next create a `configmap` that the application will use, by default it will look for a `configmap` with the same name as the application:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;console
$ kubectl create configmap hello &amp;ndash;from-literal=message=&amp;ldquo;HELLO KUBERNETES&amp;rdquo;
configmap/hello created&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Run the `curl` command again and you should see the new response:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;console
$ curl &lt;a href=&#34;http://192.168.99.103:30871&#34;&gt;http://192.168.99.103:30871&lt;/a&gt;
HELLO KUBERNETES
```&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While this was a fairly simple demonstration of the Spring Cloud Kubernetes integrations you can see how useful it can be. By integrating directly into Kubernetes you can avoid running a &lt;a href=&#34;https://spring.io/projects/spring-cloud-config&#34;&gt;Spring Cloud Config&lt;/a&gt; service to get dynamic configuration of your application.&lt;/p&gt;

&lt;p&gt;You can also load up an entire application properties file (either &lt;code&gt;.properties&lt;/code&gt; or &lt;code&gt;.yaml&lt;/code&gt;) inside a &lt;code&gt;configmap&lt;/code&gt;, you can also store passwords and keys in a Kubernetes &lt;code&gt;secret&lt;/code&gt; and dynamically load those.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Spring into Kubernetes - Deploying with Helm</title>
      <link>https://tech.paulcz.net/blog/spring-into-kubernetes-part-2/</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/spring-into-kubernetes-part-2/</guid>
      <description>Introduction In this installment of Spring into Kubernetes we&amp;rsquo;ll be looking at using Helm to install our Spring application to Kubernetes.
About Helm Helm is the package manager for Kubernetes. It provides tooling to create, template, package, and share Kubernetes manifests. A helm chart is effectively a signed tarball that contains a set of templated Kubernetes manifests, a metadata file and a set of default values.
Helm has two major components, the Helm client and the Tiller server.</description>
      <content>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In this installment of Spring into Kubernetes we&amp;rsquo;ll be looking at using &lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; to install our Spring application to Kubernetes.&lt;/p&gt;

&lt;h1 id=&#34;about-helm&#34;&gt;About Helm&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; is the package manager for Kubernetes. It provides tooling to create, template, package, and &lt;a href=&#34;https://hub.helm.sh/&#34;&gt;share&lt;/a&gt; Kubernetes manifests. A helm chart is effectively a signed tarball that contains a set of templated Kubernetes manifests, a metadata file and a set of default values.&lt;/p&gt;

&lt;p&gt;Helm has two major components, the Helm client and the Tiller server. The Helm client is a CLI tool that you use to create, package and deploy helm charts. The Tiller server is installed into your Kubernetes cluster and is responsible for managing the lifecycle of your applications as instructed by the Helm client.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: The Tiller server was created before Kubernetes extensions existed and will be removed in Helm 3 in favor of utilizing Kubernetes extensions. You can also use &amp;ldquo;tillerless&amp;rdquo; Helm but that&amp;rsquo;s out of scope for this blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Helm charts can be shared via a Helm Repository which gives you an easy way to upload, share, and download packages from a central location. The public &lt;a href=&#34;https://hub.helm.sh/&#34;&gt;Helm Hub&lt;/a&gt; has prebuilt Helm packages for most common open source applications.&lt;/p&gt;

&lt;h1 id=&#34;step-1-install-helm&#34;&gt;Step 1 - Install Helm&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.helm.sh/using_helm/#installing-helm&#34;&gt;Installing Helm&lt;/a&gt; is quite simple, if you&amp;rsquo;re on a Mac you can install Helm via Homebrew, otherwise check the &lt;a href=&#34;https://docs.helm.sh/using_helm/#installing-helm&#34;&gt;Helm install documentation&lt;/a&gt; for platform specific instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;brew install kubernetes-helm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the Helm client installed you can install the Tiller server to your Kubernetes cluster.&lt;/p&gt;

&lt;p&gt;If you are using minikube or a single tenant Kubernetes cluster without Role Based Authentication Control (RBAC) enabled you can deploy Tiller by simply running &lt;code&gt;helm init&lt;/code&gt;. On most clusters you should create a service account and role binding first like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;kubectl -n kube-system create serviceaccount tiller
kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
helm init --service-account=tiller
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a minute or so you can check it has finished installing by running &lt;code&gt;helm version&lt;/code&gt; which will give you the version of both the client and the server. If the server doesn&amp;rsquo;t respond just want a few more moments and try again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm version
Client: &amp;amp;version.Version{SemVer:&amp;quot;v2.12.2&amp;quot;, GitCommit:&amp;quot;7d2b0c73d734f6586ed222a567c5d103fed435be&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
Server: &amp;amp;version.Version{SemVer:&amp;quot;v2.12.2&amp;quot;, GitCommit:&amp;quot;7d2b0c73d734f6586ed222a567c5d103fed435be&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;step-2-create-and-deploy-a-new-helm-chart&#34;&gt;Step 2 - Create and Deploy a new Helm Chart&lt;/h1&gt;

&lt;p&gt;Use the Helm client to create a new Helm chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm create petclinic
Creating petclinic

$ cd petclinic

$ tree
‚îú‚îÄ‚îÄ charts
‚îú‚îÄ‚îÄ Chart.yaml
‚îú‚îÄ‚îÄ templates
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _helpers.tpl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ingress.yaml
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NOTES.txt
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ service.yaml
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tests
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ test-connection.yaml
‚îî‚îÄ‚îÄ values.yaml

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the Helm chart sets up a boilerplate Helm chart to get you started. This is actually a fully functioning chart so you can go ahead and deploy it right away to ensure that everything is working correctly. You could simply run &lt;code&gt;helm install .&lt;/code&gt; but generally you&amp;rsquo;ll want to specify a namespace and release name by using the &lt;code&gt;--namespace&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; for better management.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm install --namespace test --name test .
NAME:   test
LAST DEPLOYED: Tue Feb  5 06:26:19 2019
NAMESPACE: test
STATUS: DEPLOYED
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;code&gt;kubectl port-forward&lt;/code&gt; to test that everything worked right:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl --namespace test port-forward deployment/test-petclinic 8080:80
Visit http://127.0.0.1:8080 to use your application
Forwarding from [::1]:8080 -&amp;gt; 80
Forwarding from 127.0.0.1:8080 -&amp;gt; 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point your browser at &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt; and you should see the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./welcome-nginx.png&#34; alt=&#34;Nginx Welcome Screen&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But this isn&amp;rsquo;t Petclinic it&amp;rsquo;s an empty nginx container. Since our petclinic app is pretty simple we can use this boilerplate chart to deploy Petclinic with just a few minor changes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The nginx app inside the container listens on port 80, petclinic listens on port 8080 so you&amp;rsquo;ll need to edit the file &lt;code&gt;templates/deployment.yaml&lt;/code&gt; and find the YAML &lt;code&gt;containerPort: 80&lt;/code&gt; under the container spec and change the value to &lt;code&gt;8080&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Also in the &lt;code&gt;templates/deployment.yaml&lt;/code&gt; file you want to increase the initial timeout for the &lt;code&gt;livenessCheck&lt;/code&gt; check as Java takes longer to be ready than nginx. Find the YAML key &lt;code&gt;livenessProbe:&lt;/code&gt; and add the keypair &lt;code&gt;initialDelaySeconds: 60&lt;/code&gt; to it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The updated section of the &lt;code&gt;templates/deployment.yaml&lt;/code&gt; should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: &amp;quot;{{ .Values.image.repository }}:{{ .Values.image.tag }}&amp;quot;
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          livenessProbe:
            initialDelaySeconds: 60
            httpGet:
              path: /
              port: http

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: the double curly brace &lt;code&gt;{{ }}&lt;/code&gt; signifies for the golang templating engine to process some code, usually print out some values, but can also be used for if/then statements and loops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You also need to set the image and tag to petclinic. You could edit &lt;code&gt;values.yaml&lt;/code&gt; to change the defaults, but you can also override default values with &lt;code&gt;--set&lt;/code&gt;. Since we&amp;rsquo;ve already deployed the helm chart we can &lt;em&gt;upgrade&lt;/em&gt; it by running a &lt;code&gt;helm upgrade&lt;/code&gt; and providing the appropriate &lt;code&gt;--set&lt;/code&gt; flag like so:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: &lt;code&gt;helm upgrade&lt;/code&gt; helps you to manage the release lifecycle of your application, Tiller keeps track of the releases that you&amp;rsquo;ve deployed and helps you both upgrade and rollback deployments.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm upgrade test \
  --set image.repository=paulczar/spring-petclinic \
  --set image.tag=latest .
Release &amp;quot;test&amp;quot; has been upgraded. Happy Helming!
LAST DEPLOYED: Tue Feb  5 06:54:07 2019
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Forward port 8080 through to the deployment again and check its working via your web browser:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: the command shown in the &lt;code&gt;helm upgrade&lt;/code&gt; output is wrong because we&amp;rsquo;re using port 8080 now, you could fix the output by editing the file &lt;code&gt;templates/NOTES.txt&lt;/code&gt;, but for now just run the command below.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl --namespace test port-forward deployment/test-petclinic 8080
Forwarding from [::1]:8080 -&amp;gt; 8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./pc-localhost.png&#34; alt=&#34;petclinic&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;step-3-cleanup&#34;&gt;Step 3 - Cleanup&lt;/h1&gt;

&lt;p&gt;To uninstall the helm chart simple run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm delete --purge test
release &amp;quot;test&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;step-4-optional-package-your-helm-chart&#34;&gt;Step 4 (optional) - Package your Helm Chart&lt;/h1&gt;

&lt;p&gt;Helm charts are designed to be packaged and shared via a Helm repository. Simply running &lt;code&gt;helm package .&lt;/code&gt; will create the Helm package like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mkdir pkg
$ helm package -d pkg .
Successfully packaged chart and saved it to: /tmp/petclinic/petclinic-0.1.0.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These packages combined with an index file can be hosted on any static website (github pages is very common) to create a Helm Repository. You can generate the index file with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo index pkg
$ cat pkg/index.yaml
apiVersion: v1
entries:
  petclinic:
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: 2019-02-06T02:45:10.99990157-06:00
    description: A Helm chart for Kubernetes
    digest: 86f3740e6bc325ea330428e42af091d6613ca9b92678b3aecdf680f0302b4685
    name: petclinic
    urls:
    - petclinic-0.1.0.tgz
    version: 0.1.0
generated: 2019-02-06T02:45:10.99955354-06:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use any basic web server as a Helm repository, many folks are using &lt;a href=&#34;https://github.com/int128/helm-github-pages&#34;&gt;github pages&lt;/a&gt; which is quite a clever way to host your Helm Repository right next to the actual code for your Helm chart.&lt;/p&gt;

&lt;h1 id=&#34;step-5-use-a-helm-repository&#34;&gt;Step 5 - Use a Helm Repository&lt;/h1&gt;

&lt;p&gt;I have created a more featureful Helm Chart designed specifically to generically run most Spring applications which can be found on my github repo &lt;a href=&#34;https://github.com/paulczar/helm-chart-spring&#34;&gt;helm-chart-spring&lt;/a&gt;. It installs petclinic by default and has options to be able to automatically set up LoadBalancers and Ingress as well as more advanced kubernetes resources such as &lt;code&gt;podDisruptionBudgets&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can install it straight from my Helm Repository like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo add paulczar http://tech.paulcz.net/helm-chart-spring/repo
&amp;quot;paulczar&amp;quot; has been added to your repositories

$ helm install --namespace test --name test \
    paulczar/spring --set service.type=LoadBalancer \
    --version 0.0.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few moments you should be able to access the petclinic app via the LoadBalancer created by the above command.  Run &lt;code&gt;kubectl get svc&lt;/code&gt; to find the IP:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ k get svc
NAME          TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)        AGE
test-spring   LoadBalancer   10.100.200.137   35.238.37.241   80:30509/TCP   89s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point your browser at the &lt;code&gt;EXTERNAL-IP&lt;/code&gt; value:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./kube-lb-pc.png&#34; alt=&#34;petclinic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Uninstall the Helm chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm delete --purge test
release &amp;quot;test&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;Helm has made it incredibly easy to get started creating and customizing charts to install Applications on Kubernetes. By templating and packaging your Kubernetes manifests you get an easy to share package for your application and are able to enable a lot of deployment flexibility to deploy multiple releases of your application to one or many Kubernetes clusters and customize things like the service type giving you tremendous control over how people access it.&lt;/p&gt;

&lt;p&gt;Better yet, if you are looking to install an open source application you should first look to the &lt;a href=&#34;https://hub.helm.sh/&#34;&gt;Helm Hub&lt;/a&gt; which is a public repository of hundreds of pre-packaged helm charts that install with just a few keypresses.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Cloud Native Operations - Kubernetes Controllers</title>
      <link>https://tech.paulcz.net/blog/cloud-native-operations-k8s-controllers/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/cloud-native-operations-k8s-controllers/</guid>
      <description>Note: If this topic has peaked your interest, you can join me for a Webinar on August 15 where I&amp;rsquo;ll dive deep into Cloud Native Operations with Kubernetes and CI/CD Pipelines.
 Lulz what? Cloud Native Operations ?!?!?! Historically Operations practices have lagged behind development. During the 90s a number of lightweight software development practices evolved such as Scrum and Extreme Programming. During the early 2000&amp;rsquo;s it became pretty common to practice (or at least claim to) some form of Agile in software development.</description>
      <content>

&lt;blockquote&gt;
&lt;p&gt;Note: If this topic has peaked your interest, you can join me for a Webinar on August 15 where I&amp;rsquo;ll dive deep into &lt;a href=&#34;https://content.pivotal.io/webinars/aug-15-cloud-native-operations-with-kubernetes-and-ci-cd-webinar?utm_campaign=cno-k8s-ci-cd-q319&amp;amp;utm_source=blog&amp;amp;utm_medium=website&#34;&gt;Cloud Native Operations with Kubernetes and CI/CD Pipelines&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lulz-what-cloud-native-operations&#34;&gt;Lulz what? Cloud Native Operations ?!?!?!&lt;/h1&gt;

&lt;p&gt;Historically Operations practices have lagged behind development. During the 90s a number of lightweight software development practices evolved such as Scrum and Extreme Programming. During the early 2000&amp;rsquo;s it became pretty common to practice (or at least claim to) some form of Agile in software development.&lt;/p&gt;

&lt;p&gt;It wasn&amp;rsquo;t until the last year of that decade that we started to see an uptick in Operations folks wanting to adopt Agile type methodologies and as the devops (and later SRE) movements took off we started to borrow heavily from Lean principals such as Kanban and Value Stream Mapping.&lt;/p&gt;

&lt;p&gt;Cloud Computing has brought about another shift in software development, going from large monolithic applications to collections of microservices that work together, and even further into being event based via messages and streams which now falls under the umbrella of &amp;ldquo;cloud native&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;With the rise of Kubernetes and similar platforms as well as companies like Hashicorp and stalwarts of Agile Operations such as Google and Pivotal we&amp;rsquo;re starting to see that same shift in Operations as we start to talk about &lt;strong&gt;Platform as Product&lt;/strong&gt; and turning engineering [operations] teams into product teams.&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;this means we all need to learn to get better at product engineering, kittens.  and turning infra engineering teams into infra product teams. &lt;a href=&#34;https://t.co/t1Vj6RKbdd&#34;&gt;pic.twitter.com/t1Vj6RKbdd&lt;/a&gt;&lt;/p&gt;&amp;mdash; Charity Majors (@mipsytipsy) &lt;a href=&#34;https://twitter.com/mipsytipsy/status/1088673759291011073?ref_src=twsrc%5Etfw&#34;&gt;January 25, 2019&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;


&lt;h1 id=&#34;kubernetes-controllers&#34;&gt;Kubernetes Controllers&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s a lot more to be said about Cloud Native Operations and Platform as Product (the two go hand-in-hand) but for now I want to focus on a fundamental aspect of Kubernetes that will be a force multiplier for making the composable building blocks of Cloud Native Operations.&lt;/p&gt;

&lt;p&gt;Most resources in Kubernetes are managed by a Controller. A Kubernetes Controller is to microservices what a Chef recipe is to a Monolith.&lt;/p&gt;

&lt;p&gt;Each resource is controlled by its own control loop. This is a step forward from previous systems like Chef or Puppet which both have control loops but at the server level, not the resource.&lt;/p&gt;

&lt;p&gt;A Controller is a fairly simple piece of code that creates a control loop over a single resource to ensure that resource is behaving correctly. These Control loops cam stack together to create complex functionality with simple interfaces.&lt;/p&gt;

&lt;p&gt;The canonical example of this in action is in how we manage pods in Kubernetes. A Pod is [effectively] a running copy of your application that a specific worker node is asked to run. If that application crashes the kubelet running on that node will start it again.&lt;/p&gt;

&lt;p&gt;However if that node crashes the Pod is not recovered as the control loop (via the kubelet process) responsible for the resource no longer exists. To make applications more resiliant Kubernetes has the ReplicaSet controller.&lt;/p&gt;

&lt;p&gt;Kubernetes has a process running on the masters called a &lt;code&gt;controller-manager&lt;/code&gt; that run the controllers for these more advanced resources. This is where the ReplicaSet controller runs, and it is responsible for ensuring that a set number of copies of your application are always running.&lt;/p&gt;

&lt;p&gt;To do this the ReplicaSet controller requests that the provided number of Pods are created and then it routinely checks that the correct number of Pods are still running and will request more pods, or destroy existing pods to do so.&lt;/p&gt;

&lt;p&gt;By requesting a ReplicaSet from Kubernetes you get a self-healing deployment of your application. You can further add lifecycle management to your workload by requesting a Deployment which is a controller that manages ReplicaSets.&lt;/p&gt;

&lt;p&gt;These Controllers are great for managing Kubernetes resources, but are also fantastic for managing resources outside of Kubernetes. You can extend Kubernetes by writing a Controller that watches for events and annotations and performs extra work, or by writing a Custom Resource Definition.&lt;/p&gt;

&lt;h1 id=&#34;example-external-dns-controller&#34;&gt;Example - External DNS Controller&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/kubernetes-incubator/external-dns&#34;&gt;external-dns&lt;/a&gt; controller is a perfect example of a watcher. You configure it with your DNS provider and it will watch resources such as Services and Ingresses. When one of those resources changes it will inspect them for annotations which will tell it if it needs to perform an action.&lt;/p&gt;

&lt;p&gt;With the &lt;code&gt;external-dns&lt;/code&gt; controller running in your cluster you can simply add the following annotation to a service and it will go out and create a matching DNS A record for that resource:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;kubectl annotate service nginx \
    &amp;quot;external-dns.alpha.kubernetes.io/hostname=nginx.example.org.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can change other characteristics such as the TTL value of the DNS record:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;kubectl annotate service nginx \
    &amp;quot;external-dns.alpha.kubernetes.io/ttl=10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like that you now have automatic DNS management for your applications and services in Kubernetes that reacts to any changes in your cluster to ensure your DNS is correct.&lt;/p&gt;

&lt;h1 id=&#34;example-certificate-manager-operator&#34;&gt;Example - Certificate Manager Operator&lt;/h1&gt;

&lt;p&gt;Like the &lt;code&gt;external-dns&lt;/code&gt; controller the &lt;a href=&#34;http://docs.cert-manager.io/en/latest/&#34;&gt;cert-manager&lt;/a&gt; will react to changes in resources, but also comes with a Custom Resource Definition that will allow you to request certificates as a resource in of themselves, not just a byproduct of an annotation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cert-manager&lt;/code&gt; works with &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Lets Encrypt&lt;/a&gt; and other sources of Certificates to request valid signed TLS certificates. You can even use it in combination with &lt;code&gt;external-dns&lt;/code&gt; like the following which will register &lt;code&gt;web.example.com&lt;/code&gt; and retrieve a TLS certificate from Lets Encrypt and store that in a Secret.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    certmanager.k8s.io/acme-http01-edit-in-place: &amp;quot;true&amp;quot;
    certmanager.k8s.io/cluster-issuer: letsencrypt-prod
    kubernetes.io/tls-acme: &amp;quot;true&amp;quot;
  name: example
spec:
  rules:
  - host: web.example.com
    http:
      paths:
      - backend:
          serviceName: example
          servicePort: 80
        path: /*
  tls:
  - hosts:
    - web.example.com
    secretName: example-tls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also request a certificate directly from the &lt;code&gt;cert-manager&lt;/code&gt; CRD like so which like above will result in a certificate keypair being stored in a Kubernetes secret:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: example-com
  namespace: default
spec:
  secretName: example-com-tls
  issuerRef:
    name: letsencrypt-staging
  commonName: example.com
  dnsNames:
  - www.example.com
  acme:
    config:
    - http01:
        ingressClass: nginx
      domains:
      - example.com
    - http01:
        ingress: my-ingress
      domains:
      - www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;This was just a quick look at one of the ways that Kubernetes is helping enable a new wave of changes to how we operate software. This is a favorite topic of mine, so look forward to hearing more.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Building Spring Docker Images</title>
      <link>https://tech.paulcz.net/blog/building-spring-docker-images/</link>
      <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/building-spring-docker-images/</guid>
      <description>While investigating running Spring applications on Kubernetes I discovered that a lot of the existing example Spring applications do not have a Dockerfile in their git repository. I thought this odd at first (and frankly still do).
What I discovered though, is there&amp;rsquo;s quite a number of ways to build Spring (and Java in general) container images that don&amp;rsquo;t necessarily rely on writing a Dockerfile.
Full disclosure, I am a firm believe that any opensource project of consequence (where feasible) should ship a Dockerfile in their git repo, and ideally have images up on the Docker hub (or other public container registry) as it allows for newcomers to experience your application or project in just a few seconds with no need to play detective to try and figure out how to get it running.</description>
      <content>

&lt;p&gt;While investigating running &lt;a href=&#34;https://spring.io&#34;&gt;Spring&lt;/a&gt; applications on Kubernetes I discovered that a lot of the existing example Spring applications do not have a &lt;code&gt;Dockerfile&lt;/code&gt; in their git repository. I thought this odd at first (and frankly still do).&lt;/p&gt;

&lt;p&gt;What I discovered though, is there&amp;rsquo;s quite a number of ways to build &lt;a href=&#34;https://spring.io/guides/gs/spring-boot-docker/&#34;&gt;Spring (and Java in general) container images&lt;/a&gt; that don&amp;rsquo;t necessarily rely on writing a Dockerfile.&lt;/p&gt;

&lt;p&gt;Full disclosure, I am a firm believe that any opensource project of consequence (where feasible) should ship a Dockerfile in their git repo, and ideally have images up on the Docker hub (or other public container registry) as it allows for newcomers to experience your application or project in just a few seconds with no need to play detective to try and figure out how to get it running.&lt;/p&gt;

&lt;p&gt;I will demonstrate building the &lt;a href=&#34;https://github.com/spring-projects/spring-petclinic&#34;&gt;Spring Pet Clinic example application&lt;/a&gt; into container images.&lt;/p&gt;

&lt;p&gt;If you want to follow along at home start by cloning down the repo to your local machine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;git clone https://github.com/spring-projects/spring-petclinic.git

cd spring-petclinic
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;option-1-dockerfile&#34;&gt;Option 1 - Dockerfile&lt;/h1&gt;

&lt;p&gt;The Pet Clinic app uses Maven to build a .jar file, so we have a few options here.&lt;/p&gt;

&lt;h2 id=&#34;build-jar-and-then-copy-it-into-a-java-image&#34;&gt;Build .jar and then copy it into a Java Image&lt;/h2&gt;

&lt;p&gt;This assumes that you have a suitable version of Java and Maven on your system.&lt;/p&gt;

&lt;p&gt;Start by building the project into a .jar file with Maven:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mvn install -DskipTests
[INFO] Installing /home/pczarkowski/development/demo/spring-into-kubernetes-1/spring-petclinic/target/spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar to /home/pczarkowski/.m2/repository/org/springframework/samples/spring-petclinic/2.1.0.BUILD-SNAPSHOT/spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar
[INFO] Installing /home/pczarkowski/development/demo/spring-into-kubernetes-1/spring-petclinic/pom.xml to /home/pczarkowski/.m2/repository/org/springframework/samples/spring-petclinic/2.1.0.BUILD-SNAPSHOT/spring-petclinic-2.1.0.BUILD-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 26.984 s
[INFO] Finished at: 2019-01-25T09:23:11-06:00
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see this resulted in a Java file &lt;code&gt;spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar&lt;/code&gt;.  We can create a Dockerfile to ingest this called &lt;code&gt;Dockerfile.cp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;FROM openjdk:11.0.1-jre-slim-stretch
EXPOSE 8080
ARG JAR=spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar
COPY target/$JAR /app.jar
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: because we already built the Jar we only need a slim JRE image to run it in. We can also use an ARG for the file name in case we need to change it on build with &lt;code&gt;--build-arg JAR=...&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A simple &lt;code&gt;docker build&lt;/code&gt; command should create us an image we can run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;docker build -f ./Dockerfile.cp -t spring/petclinic .
Sending build context to Docker daemon  98.22MB
Step 1/5 : FROM openjdk:11.0.1-jre-slim-stretch
11.0.1-jre-slim-stretch: Pulling from library/openjdk
5e6ec7f28fb7: Pull complete
1cf4e4a3f534: Pull complete
5d9d21aca480: Pull complete
0a126fb8ec28: Pull complete
1904df324545: Pull complete
e6d9d96381c8: Pull complete
Digest: sha256:965a07951bee0c3b1f8aff4818619ace3e675d91cfb746895e8fb84e3e6b13ca
Status: Downloaded newer image for openjdk:11.0.1-jre-slim-stretch
 ---&amp;gt; 49b31a72a85a
Step 2/5 : EXPOSE 8080
 ---&amp;gt; Running in 1aeaae727a80
Removing intermediate container 1aeaae727a80
 ---&amp;gt; a1a1850f8e8f
Step 3/5 : ARG JAR=spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar
 ---&amp;gt; Running in b6faa7c0faa3
Removing intermediate container b6faa7c0faa3
 ---&amp;gt; 2b55681ac9df
Step 4/5 : COPY target/$JAR /app.jar
 ---&amp;gt; dec4f0d56c9d
Step 5/5 : ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
 ---&amp;gt; Running in f492e1668fff
Removing intermediate container f492e1668fff
 ---&amp;gt; f669afd61b8d
Successfully built f669afd61b8d
Successfully tagged spring/petclinic:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start the new container, wait a minute or so (you can watch the logs with &lt;code&gt;docker logs -f petclinic&lt;/code&gt; if you want), and then test it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d --name petclinic -p 8080:8080 spring/petclinic
a1d51b6f9a47501dfe90f24866e7fb6c82e436323fa4adc09074e8ac7447a1a7

$ curl -s localhost:8080 | head
&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;

  &amp;lt;head&amp;gt;

    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;/&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;

$ docker rm -f petclinic
petclinic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can look at the resultant image size using &lt;code&gt;docker images&lt;/code&gt;, if you want to dive deeper you can also use &lt;code&gt;docker inspect&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker images spring/petclinic
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
spring/petclinic    latest              f669afd61b8d        41 minutes ago      318MB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;use-a-multi-stage-dockerfile&#34;&gt;Use a multi-stage Dockerfile&lt;/h2&gt;

&lt;p&gt;If you don&amp;rsquo;t have Java and Maven on your system, or you want to delegate the whole thing to Docker you can utilize a multi-stage Dockerfile to build the .jar file and then copy it into a slim image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM maven:3.6-jdk-11-slim as BUILD
COPY . /src
WORKDIR /src
RUN mvn install -DskipTests

FROM openjdk:11.0.1-jre-slim-stretch
EXPOSE 8080
WORKDIR /app
ARG JAR=spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar

COPY --from=BUILD /src/target/$JAR /app.jar
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like before we can use &lt;code&gt;docker build&lt;/code&gt; to build this image, but unlike before we don&amp;rsquo;t need Java or Maven installed locally:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker build -f ./Dockerfile.multi -t spring/petclinic .
...
...
Successfully built ee062471d65c
Successfully tagged spring/petclinic:latest

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
spring/petclinic    latest              ee062471d65c        18 minutes ago      318MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you&amp;rsquo;d expect the Docker Image size is the same as the previous build given we effectively did the same thing, build the Jar and then Copy it into a slim image.&lt;/p&gt;

&lt;h1 id=&#34;option-2-google-jib&#34;&gt;Option 2 - Google JIB&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/GoogleContainerTools/jib&#34;&gt;Jib&lt;/a&gt; builds optimized Docker and OCI images for your Java applications without a Docker daemon - and without deep mastery of Docker best-practices. It is available as plugins for Maven and Gradle and as a Java library.&lt;/p&gt;

&lt;p&gt;Normally you&amp;rsquo;d add JIB to your maven build via the pom.xml [as shown here].(&lt;a href=&#34;https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin#setup&#34;&gt;https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin#setup&lt;/a&gt;), To kick the tires we can just pass some extra arguments to maven and get the same result.&lt;/p&gt;

&lt;p&gt;You can build your image with JIB (you don&amp;rsquo;t even need Docker running!) and ship it straight up to the docker registry by running the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: In this example I am using my docker registry username in the image name so that it is uploaded correctly, you&amp;rsquo;ll want to swap out &lt;code&gt;paulczar&lt;/code&gt; for your own username.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mvn compile com.google.cloud.tools:jib-maven-plugin:1.0.0:build -Dimage=paulczar/petclinic:jib -DskipTests
[INFO] Containerizing application to paulczar/petclinic:jib...
[WARNING] Base image &#39;gcr.io/distroless/java&#39; does not use a specific image digest - build may not be reproducible
[INFO]
[INFO] Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, org.springframework.samples.petclinic.PetClinicApplication]
[INFO]
[INFO] Built and pushed image as paulczar/petclinic:jib
[INFO] Executing tasks:
[INFO] [==============================] 100.0% complete
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 57.478 s
[INFO] Finished at: 2019-01-25T11:03:25-06:00
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This provides a warning &lt;code&gt;build may not be reproducible&lt;/code&gt;. You can pass an argument to use your own base Java image to make it more deterministic by adding &lt;code&gt;-Djib.from.image=openjdk:11.0.1-jre-slim-stretch&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you want JIB to build against your local docker install and not push the image to the registry you can run the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mvn compile com.google.cloud.tools:jib-maven-plugin:1.0.0:dockerBuild
...
...
[INFO] Built image to Docker daemon as spring-petclinic:2.1.0.BUILD-SNAPSHOT
[INFO] Executing tasks:
[INFO] [==============================] 100.0% complete
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 10.485 s
[INFO] Finished at: 2019-01-25T11:14:21-06:00
[INFO] ------------------------------------------------------------------------

docker images spring-petclinic:2.1.0.BUILD-SNAPSHOT
REPOSITORY          TAG                    IMAGE ID            CREATED             SIZE
spring-petclinic    2.1.0.BUILD-SNAPSHOT   79d677deeedb        49 years ago        164MB
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This image is much smaller than the rest, this is because by default JIB creates a distroless Java image. This might seem like a good idea for the size, but will like the warning from the previous build give you an image that may not be reproducable. I recommend always using the &lt;code&gt;-Djib.from.image=openjdk:11.0.1-jre-slim-stretch&lt;/code&gt; argument to choose your upstream Java image which will again give you a 318Mb image like the previous builds.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;others&#34;&gt;Others&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve shown you what I believe are the best methods for building a Docker image for your Spring application. There are some other maven plugins that do the same thing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spotify/dockerfile-maven&#34;&gt;Spotify/dockerfile-maven&lt;/a&gt; builds a Jar and then uses a user provided Dockerfile to copy it in.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spotify/docker-maven-plugin&#34;&gt;spotify/docker-maven&lt;/a&gt; builds the whole image for you much like JIB.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fabric8io/docker-maven-plugin&#34;&gt;fabricate/docker-maven&lt;/a&gt; also builds the whole image like JIB.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Hopefully after reading this you have a better idea how to build Docker images for your Spring (or general Java) Application. Personally I prefer the multi-stage Dockerfile as your Dockerfile becomes the contract on how your image is built, however I do really like the way i can use JIB to build an image without needing Docker as this simplifies my build environment and means I can very easily use tools like &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt; or &lt;a href=&#34;https://drone.io&#34;&gt;Drone&lt;/a&gt; to build my images for me.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Spring into Kubernetes - Part 1</title>
      <link>https://tech.paulcz.net/blog/spring-into-kubernetes-part-1/</link>
      <pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/spring-into-kubernetes-part-1/</guid>
      <description>Introduction Welcome to the first part in a series of blog posts looking at running Spring applications on Kubernetes. To kick the series off we&amp;rsquo;re going to take a look at the Spring Pet Clinic example application and demonstrate how we can quickly and easily get it running on Kubernetes.
Step 1. Install a Kubernetes Before we get started I would encourage you to read (or at least skim) through Kelsey Hightower&amp;rsquo;s seminal Kubernetes The Hard Way to get an idea for the complexity of installing and operating a Kubernetes cluster.</description>
      <content>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Welcome to the first part in a series of blog posts looking at running Spring applications on Kubernetes. To kick the series off we&amp;rsquo;re going to take a look at the &lt;a href=&#34;https://github.com/spring-projects/spring-petclinic&#34;&gt;Spring Pet Clinic&lt;/a&gt; example application and demonstrate how we can quickly and easily get it running on Kubernetes.&lt;/p&gt;

&lt;h1 id=&#34;step-1-install-a-kubernetes&#34;&gt;Step 1.  Install a Kubernetes&lt;/h1&gt;

&lt;p&gt;Before we get started I would encourage you to read (or at least skim) through Kelsey Hightower&amp;rsquo;s seminal &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34;&gt;Kubernetes The Hard Way&lt;/a&gt; to get an idea for the complexity of installing and operating a Kubernetes cluster.&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve done that you should be thoroughly discouraged from installing Kubernetes. That&amp;rsquo;s a good thing! Most people should have no need to run their own production grade Kubernetes cluster. Every major public cloud has a Kubernetes service, and Pivotal provides the &lt;a href=&#34;https://pivotal.io/platform/pivotal-container-service&#34;&gt;Pivotal Container Service&lt;/a&gt; to ease the burden of installing and managing Kubernetes in your own Datacenter.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll be using &lt;a href=&#34;https://pivotal.io/platform/pivotal-container-service&#34;&gt;Pivotal Container Service&lt;/a&gt;. You should be able to use any flavor of Kubernetes to follow along with this series of blog posts. The simplest way to do so is to probably install and run &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube/&#34;&gt;Minikube&lt;/a&gt; which will give you a single node Kubernetes cluster running in a VM on your laptop.&lt;/p&gt;

&lt;h1 id=&#34;step-2-validate-your-kubernetes-cluster-is-ready&#34;&gt;Step 2. Validate your Kubernetes cluster is ready&lt;/h1&gt;

&lt;p&gt;However you got your Kubernetes cluster is between you and your deity of choice and I won&amp;rsquo;t ask any questions. You should have received [or had one automatically created] a Kubernetes config file and you should have downloaded the &lt;code&gt;kubectl&lt;/code&gt; command line tool.&lt;/p&gt;

&lt;p&gt;Run the following commands to ensure that your Kubernetes config and cluster are working correctly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl version
kubClient Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;13&amp;quot;, GitVersion:&amp;quot;v1.13.2&amp;quot;, GitCommit:&amp;quot;cff46ab41ff0bb44d8584413b598ad8360ec1def&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;, BuildDate:&amp;quot;2019-01-10T23:35:51Z&amp;quot;, GoVersion:&amp;quot;go1.11.4&amp;quot;, Compiler:&amp;quot;gc&amp;quot;, Platform:&amp;quot;linux/amd64&amp;quot;}
Server Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;12&amp;quot;, GitVersion:&amp;quot;v1.12.4&amp;quot;, GitCommit:&amp;quot;f49fa022dbe63faafd0da106ef7e05a29721d3f1&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;, BuildDate:&amp;quot;2018-12-14T06:59:37Z&amp;quot;, GoVersion:&amp;quot;go1.10.4&amp;quot;, Compiler:&amp;quot;gc&amp;quot;, Platform:&amp;quot;linux/amd64&amp;quot;}

$ kubectl get nodes
NAME                                      STATUS   ROLES    AGE     VERSION
vm-16ff7fc4-88fa-406d-5f6a-7ccc92286c08   Ready    &amp;lt;none&amp;gt;   2d11h   v1.12.4
vm-5bfb8f6e-d715-45ba-77df-047447995ac1   Ready    &amp;lt;none&amp;gt;   2d11h   v1.12.4
vm-c2c16e34-1a73-4a78-50b4-bdec12d3de77   Ready    &amp;lt;none&amp;gt;   2d11h   v1.12.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;looking great! Create a namespace to work in that you can delete when finished to easily clean up after the demo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl create namespace spring-into-kubernetes-1
namespace/spring-into-kubernetes-1 created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update your Kubernetes config to use this new namespace by default:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl config set-context $(kubectl config current-context) --namespace=spring-into-kubernetes-1
Context &amp;quot;cluster1&amp;quot; modified.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;step-3-build-a-docker-image-for-spring-pet-clinic&#34;&gt;Step 3. Build a Docker image for Spring Pet Clinic&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: If you are using minikube you can use the &lt;a href=&#34;https://github.com/kubernetes/minikube/blob/master/docs/reusing_the_docker_daemon.md&#34;&gt;minikube docker socket&lt;/a&gt; and skip pushing the image up to a registry.&lt;/p&gt;

&lt;p&gt;Note: If you don&amp;rsquo;t want to build your own image you can use the one that I&amp;rsquo;ve already built &lt;code&gt;paulczar/petclinic:spring-k8s-1&lt;/code&gt; and skip straight to running it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Use &lt;code&gt;git&lt;/code&gt; to clone down the Spring Pet Clinic git repo locally:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git clone https://github.com/spring-projects/spring-petclinic.git
Cloning into &#39;spring-petclinic&#39;...
remote: Enumerating objects: 7860, done.
remote: Total 7860 (delta 0), reused 0 (delta 0), pack-reused 7860
Receiving objects: 100% (7860/7860), 6.99 MiB | 14.57 MiB/s, done.
Resolving deltas: 100% (2908/2908), done.

$ cd spring-petclinic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ordinarily you&amp;rsquo;d use &lt;code&gt;docker build&lt;/code&gt; to create a docker image, however this repo does not have a &lt;code&gt;Dockerfile&lt;/code&gt;, so thankfully we have some less obvious ways through maven to do this using tools like the &lt;a href=&#34;https://github.com/GoogleContainerTools/jib&#34;&gt;Google JIB project&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: For more ways to build Docker images for Spring Applications see the official &lt;a href=&#34;https://spring.io/guides/gs/spring-boot-docker/&#34;&gt;Spring documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mvn compile -Dimage=spring/petclinic:spring-k8s-1 \
    com.google.cloud.tools:jib-maven-plugin:1.0.0:dockerBuild
...
...
[INFO] Built image to Docker daemon as spring-petclinic:2.1.0.BUILD-SNAPSHOT
[INFO] Executing tasks:
[INFO] [==============================] 100.0% complete
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 20.561 s
[INFO] Finished at: 2019-01-24T08:56:30-06:00
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If like me you don&amp;rsquo;t have &lt;code&gt;java&lt;/code&gt; installed on your local desktop you can cheat your way through by mapping your docker socket through to a maven container like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker run -ti --rm --workdir /src -v $(pwd):/src \
    -v /var/run/docker.sock:/var/run/docker.sock \
    maven:3.6-jdk-11 mvn compile -Dimage=spring/petclinic:spring-k8s-1 \
    com.google.cloud.tools:jib-maven-plugin:1.0.0:dockerBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will have built an image called &lt;code&gt;spring/petclinic:spring-k8s-1&lt;/code&gt;. Verify it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker images spring/petclinic:spring-k8s-1
REPOSITORY          TAG                    IMAGE ID            CREATED             SIZE
spring/petclinic    spring-k8s-1   6afb36ee7749        15 seconds ago        164MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tag this image for your Docker registry username (anywhere you see my registry username you should swap it for yours) and push it up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker tag spring/petclinic:spring-k8s-1 paulczar/petclinic:spring-k8s-1
$ docker push paulczar/petclinic:spring-k8s-1
The push refers to repository [docker.io/paulczar/petclinic]
1f5a2dd7582f: Layer already exists
6e01ddadb469: Pushed
185699264bb4: Layer already exists
5b0bbc8b30cc: Pushed
6189abe095d5: Pushed
c5204564c844: Pushed
spring-k8s-1: digest: sha256:0a71768b0a3b199b6ec78dff983f26c4103e6089ed50c17985b58c120c3aaf72 size: 1581

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;step-4-optional-validate-the-docker-image-works-locally&#34;&gt;Step 4. (optional) Validate the Docker Image works locally&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s usually a good idea to validate things locally in Docker before moving ahead, so go ahead and do that by running Spring Petclinic via your local docker daemon:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We&amp;rsquo;re running docker with the &lt;code&gt;-ti&lt;/code&gt; flag to keep it in the foreground, &lt;code&gt;--rm&lt;/code&gt; to delete the container when done and &lt;code&gt;-p&lt;/code&gt; to map a port from localhost.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker run -ti --rm -p 8080:8080 paulczar/petclinic:spring-k8s-1
...
...
2019-01-24 15:07:35.928  INFO 1 --- [  restartedMain] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 15 endpoint(s) beneath base path &#39;/manage&#39;
2019-01-24 15:07:36.057  INFO 1 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#39;&#39;
2019-01-24 15:07:36.061  INFO 1 --- [  restartedMain] o.s.s.petclinic.PetClinicApplication     : Started PetClinicApplication in 7.151 seconds (JVM running for 7.522)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validate it works by pointint your web browser at localhost port 8080:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./pc-localhost.png&#34; alt=&#34;Spring Pet Clinic via Docker&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Stop and delete your running container by hitting &lt;code&gt;control c&lt;/code&gt; in the terminal running the docker image.&lt;/p&gt;

&lt;h1 id=&#34;step-5-run-pet-clinic-in-kubernetes&#34;&gt;Step 5. Run Pet Clinic in Kubernetes&lt;/h1&gt;

&lt;p&gt;There are two main ways of interacting with Kubernetes. &lt;strong&gt;declarative&lt;/strong&gt; and &lt;strong&gt;imperative&lt;/strong&gt;. With declarative you run &lt;code&gt;kubectl apply&lt;/code&gt; with a local copy of the Kubernetes manifest and let Kubernetes determine how to ensure the running resources matches. When you use Kubernetes imperatively you give it more precise commands like &lt;code&gt;kubectl create&lt;/code&gt; and &lt;code&gt;kubectl run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most advanced users of Kubernetes use the declarative methods, but the imperative are perfect for when you&amp;rsquo;re just getting started or want to do something quickly.&lt;/p&gt;

&lt;p&gt;Create a Kubernetes deployment by running the &lt;code&gt;kubectl create&lt;/code&gt; command and then validate it with &lt;code&gt;kubectl get all&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl create deployment petclinic --image=paulczar/petclinic:spring-k8s-1
deployment.apps/petclinic created

$ kubectl get all
NAME                             READY   STATUS    RESTARTS   AGE
pod/petclinic-5ffccf75c4-snhdd   1/1     Running   0          36s

NAME                        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/petclinic   1         1         1            1           36s

NAME                                   DESIRED   CURRENT   READY   AGE
replicaset.apps/petclinic-5ffccf75c4   1         1         1       36s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that Kubernetes has created several resources. It created a &lt;strong&gt;Deployment&lt;/strong&gt; which is reconciled by a &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/&#34;&gt;Kubernetes controller&lt;/a&gt; for managing the lifecycle of &lt;strong&gt;ReplicaSets&lt;/strong&gt;. The &lt;strong&gt;Deployment&lt;/strong&gt; created the &lt;strong&gt;ReplicaSet&lt;/strong&gt; which has a controller for ensuring a set number of replicas of your application is running. The &lt;strong&gt;ReplicaSet&lt;/strong&gt; created a &lt;strong&gt;Pod&lt;/strong&gt; which is your running application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/&#34;&gt;Controllers&lt;/a&gt; are a major part of what makes Kubernetes so good. They create tight control loops around resources to add more complex functionality as described above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You might notice that the Kubernetes output above does not give you an IP address or any hints as to how to access your application. This is because we need to expose the application using a &lt;strong&gt;Service&lt;/strong&gt; resource.&lt;/p&gt;

&lt;h1 id=&#34;step-6-expose-your-application-to-the-internet&#34;&gt;Step 6. Expose your application to the Internet&lt;/h1&gt;

&lt;p&gt;If you don&amp;rsquo;t care about making your application available to the internet and just want to validate that it works you can run &lt;code&gt;kubectl port-forward&lt;/code&gt; and access your application via a &lt;code&gt;localhost&lt;/code&gt; port forward like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;kubectl port-forward deployment/petclinic 8080:8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
Forwarding from [::1]:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access the petclinic app just like we did earlier by pointing your browser at localhost:8080:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./pc-localhost.png&#34; alt=&#34;Spring Pet Clinic via Docker&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Stop the port forward with a &lt;code&gt;control-C&lt;/code&gt; on in the terminal.&lt;/p&gt;

&lt;p&gt;Use the &lt;code&gt;kubectl expose&lt;/code&gt; command to create a LoadBalancer service in Kubernetes and then validate it with &lt;code&gt;kubectl get services&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl expose deployment petclinic --type=LoadBalancer --port 80 --target-port 8080
service/petclinic exposed

$ kubectl get service
NAME        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
petclinic   LoadBalancer   10.100.200.110   &amp;lt;pending&amp;gt;     80:31148/TCP   15s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few minutes the &lt;code&gt;EXTERNAL-IP&lt;/code&gt; field should go from &lt;code&gt;&amp;lt;pending&amp;gt;&lt;/code&gt; to having an IP address:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl get service
NAME        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
petclinic   LoadBalancer   10.100.200.110   35.238.37.241    80:31148/TCP   15s
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: If you are running minikube you won&amp;rsquo;t get a real loadbalancer and can run &lt;code&gt;minikube service example-service --url&lt;/code&gt; to get an IP/Port combo that should work.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Point your web browser at that IP address on port 80:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./kube-lb-pc.png&#34; alt=&#34;Spring Pet Clinic via Docker&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;step-7-cleanup&#34;&gt;Step 7. Cleanup&lt;/h1&gt;

&lt;p&gt;Delete the service and deployment by running the &lt;code&gt;kubectl delete&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ k8s-platform-ops kubectl delete deployment petclinic
deployment.extensions &amp;quot;petclinic&amp;quot; deleted
$ k8s-platform-ops kubectl delete service petclinic
$ k8s-platform-ops kubectl get all
No resources found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delete your namespace and switch back to the &lt;code&gt;default&lt;/code&gt; namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl delete namespace spring-into-kubernetes-1
namespace &amp;quot;spring-into-kubernetes-1&amp;quot; deleted

$ kubectl config set-context $(kubectl config current-context) --namespace=default
Context &amp;quot;cluster1&amp;quot; modified.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Congratulations! You&amp;rsquo;ve successfully deployed a basic Spring application to Kubernetes and it wasn&amp;rsquo;t even all that hard.&lt;/p&gt;

&lt;p&gt;Using Kubernetes imperatively like this is a great way to get started and easily demonstrate running an application on Kubernetes. Of course there&amp;rsquo;s many more things to take into consideration if you want to run an application in production on Kubernetes and we&amp;rsquo;ll explore some of those things in future installments of Spring Into Kubernetes.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>