<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ssl on Paul Czarkowski</title>
    <link>https://tech.paulcz.net/categories/ssl/</link>
    <description>Recent content in ssl on Paul Czarkowski</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tech.paulcz.net/categories/ssl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Creating Self Signed Certificates on Kubernetes</title>
      <link>https://tech.paulcz.net/blog/creating-self-signed-certs-on-kubernetes/</link>
      <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/creating-self-signed-certs-on-kubernetes/</guid>
      <description>Welcome to 2020. Creating self signed TLS certificates is still hard. Five (5) years ago I created a project on github called omgwtfssl which is a fairly simple bash script wrapping a bunch of openssl commands to create certificates.
I&amp;rsquo;ve been using it ever since and kind of forgot about the pain of creating certificates.
Skip the words and jump to the examples Creating self signed certificates with cert-manager, Creating multiple certificates from the same self signed CA with cert-manager.</description>
      <content>

&lt;p&gt;Welcome to 2020. Creating self signed TLS certificates is still hard. Five (5) years ago I created a project on github called &lt;a href=&#34;https://github.com/paulczar/omgwtfssl&#34;&gt;omgwtfssl&lt;/a&gt; which is a fairly simple bash script wrapping a bunch of &lt;code&gt;openssl&lt;/code&gt; commands to create certificates.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been using it ever since and kind of forgot about the pain of creating certificates.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Skip the words and jump to the examples &lt;a href=&#34;#creating-self-signed-certificates-with-cert-manager&#34;&gt;Creating self signed certificates with cert-manager&lt;/a&gt;, &lt;a href=&#34;#creating-multiple-certificates-from-the-same-self-signed-ca-with-cert-manager&#34;&gt;Creating multiple certificates from the same self signed CA with cert-manager&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With the advent of &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;letsencrypt&lt;/a&gt; and later the Kubernetes &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt; controller we can make real signed certificates with a quick flourish of some &lt;strong&gt;YAML&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been happily chugging along with this combination of &lt;code&gt;cert-manager&lt;/code&gt; &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt; for real certificates, and &lt;a href=&#34;https://github.com/paulczar/omgwtfssl&#34;&gt;omgwtfssl&lt;/a&gt; for self signed (despite the fact that the name is &lt;a href=&#34;https://gitlab.com/gitlab-org/charts/gitlab/issues/584&#34;&gt;inappropriate and unprofessional.&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;We should try to find a replacement for omgwtfssl, which is currently used to generate self-signed certificates. The name is inappropriate and unprofessional.&amp;rdquo;  - &lt;a href=&#34;https://gitlab.com/gitlab-org/charts/gitlab/issues/584&#34;&gt;gitlab&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As amusing as &lt;code&gt;docker run paulczar/omgwtfssl&lt;/code&gt; is to type (I giggle every time), its a bit weird to tell people to create certificates locally then add them to their Kubernetes manifests or Helm charts. So I finally decided to sit down and figure out how to create them sensibly with &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;create-a-kubernetes-in-docker-cluster&#34;&gt;Create a Kubernetes in Docker Cluster&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll need a Kubernetes cluster, we&amp;rsquo;re not doing anything too resource intensive so a &lt;a href=&#34;https://kind.sigs.k8s.io/docs/user/quick-start/&#34;&gt;kind&lt;/a&gt; cluster should be fine.&lt;/p&gt;

&lt;p&gt;Create &lt;a href=&#34;https://kind.sigs.k8s.io/docs/user/quick-start/&#34;&gt;kind&lt;/a&gt; cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kind create cluster
export KUBECONFIG=&amp;quot;$(kind get kubeconfig-path --name=&amp;quot;kind&amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test the cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl cluster-info
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-self-signed-certificates-with-cert-manager&#34;&gt;Creating self signed certificates with cert-manager&lt;/h2&gt;

&lt;p&gt;Install &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create namespace cert-manager
kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.13.1/cert-manager.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you receive a validation error relating to the x-kubernetes-preserve-unknown-fields add &lt;code&gt;--validate&lt;/code&gt; to the above command and run again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Create a namespace to work in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create namespace sandbox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create an Issuer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: you can create a ClusterIssuer instead if you want to be able to request certificates from any namespace.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox -f &amp;lt;(echo &amp;quot;
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}
&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a self signed certificate:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This creates a wildcard certificate that could be used for
  any services in the sandbox namespace.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox -f &amp;lt;(echo &#39;
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: first-tls
spec:
  secretName: first-tls
  dnsNames:
  - &amp;quot;*.sandbox.svc.cluster.local&amp;quot;
  - &amp;quot;*.sandbox&amp;quot;
  issuerRef:
    name: selfsigned-issuer
&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Validate the secret is created&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Check the certificate resource:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n sandbox get certificate
  NAME        READY   SECRET      AGE
  first-tls   True    first-tls   9s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the subsequent secret:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n sandbox get secret first-tls
NAME        TYPE                DATA   AGE
first-tls   kubernetes.io/tls   3      73s
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;This secret contains three keys &lt;code&gt;ca.crt&lt;/code&gt;, &lt;code&gt;tls.crt&lt;/code&gt;, &lt;code&gt;tls.key&lt;/code&gt;. You can run &lt;code&gt;kubectl -n sandbox get secret first-tls -o yaml&lt;/code&gt; to see the whole thing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Test that the certificate is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl x509 -in &amp;lt;(kubectl -n sandbox get secret \
  first-tls -o jsonpath=&#39;{.data.tls\.crt}&#39; | base64 -d) \
  -text -noout
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you scan through the output you should find &lt;code&gt;X509v3 Subject Alternative Name: DNS:*.first.svc.cluster.local, DNS:*.first&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Congratulations. You&amp;rsquo;ve just created your first self signed certificate with Kubernetes. While it involves more typing than &lt;code&gt;docker run paulczar/omgwtfssl&lt;/code&gt; it is much more useful for Kubernetes enthusiasts to have the cluster generate them for you.&lt;/p&gt;

&lt;p&gt;However, what if you want to use TLS certificates signed by the same CA for performing client/server authentication? Never fear we can do that too.&lt;/p&gt;

&lt;h2 id=&#34;creating-multiple-certificates-from-the-same-self-signed-ca-with-cert-manager&#34;&gt;Creating multiple certificates from the same self signed CA with cert-manager&lt;/h2&gt;

&lt;p&gt;Install &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Skip this step if you already installed cert-manager from the first example.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create namespace cert-manager
kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.13.1/cert-manager.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you receive a validation error relating to the x-kubernetes-preserve-unknown-fields add &lt;code&gt;--validate&lt;/code&gt; to the above command and run again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Create a namespace to work in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create namespace sandbox2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create an Issuer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: you can create a ClusterIssuer instead if you want to be able to request certificates from any namespace.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox2 -f &amp;lt;(echo &amp;quot;
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}
&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a CA Certificate:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;note &lt;code&gt;isCA&lt;/code&gt; is set to true in the body of the &lt;code&gt;spec&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox2 -f &amp;lt;(echo &#39;
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: sandbox2-ca
spec:
  secretName: sandbox2-ca-tls
  commonName: sandbox2.svc.cluster.local
  usages:
    - server auth
    - client auth
  isCA: true
  issuerRef:
    name: selfsigned-issuer
&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the certificate and secret were created:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n sandbox2 get certificate sandbox2-ca
NAME          READY   SECRET            AGE
sandbox2-ca   True    sandbox2-ca-tls   15s

$ kubectl -n sandbox2 get secret sandbox2-ca-tls
NAME              TYPE                DATA   AGE
sandbox2-ca-tls   kubernetes.io/tls   3      22s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a second Issuer using the secret name from the &lt;code&gt;sandbox2-ca&lt;/code&gt; secret:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In order to sign multiple certificates from the same CA we need to create an Issuer resource from secret created by the CA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox2 -f &amp;lt;(echo &#39;
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
  name: sandbox2-ca-issuer
spec:
  ca:
    secretName: sandbox2-ca-tls&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a TLS Certificate from the new CA Issuer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We can add &lt;code&gt;usages&lt;/code&gt; to the certificate &lt;code&gt;spec&lt;/code&gt; to ensure that the certificates can be used for client/server authentication.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox2 -f &amp;lt;(echo &#39;
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: sandbox2-server
spec:
  secretName: sandbox2-server-tls
  isCA: false
  usages:
    - server auth
    - client auth
  dnsNames:
  - &amp;quot;server.sandbox2.svc.cluster.local&amp;quot;
  - &amp;quot;server&amp;quot;
  issuerRef:
    name: sandbox2-ca-issuer
&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a second TLS Certificate from the new CA Issuer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -n sandbox2 -f &amp;lt;(echo &#39;
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: sandbox2-client
spec:
  secretName: sandbox2-client-tls
  isCA: false
  usages:
    - server auth
    - client auth
  dnsNames:
  - &amp;quot;client.sandbox2.svc.cluster.local&amp;quot;
  - &amp;quot;client&amp;quot;
  issuerRef:
    name: sandbox2-ca-issuer
&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check that all three certificates are created:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n sandbox2 get certificate
NAME              READY   SECRET                AGE
sandbox2-ca       True    sandbox2-ca-tls       7m34s
sandbox2-client   True    sandbox2-client-tls   7s
sandbox2-server   True    sandbox2-server-tls   16s

$ kubectl -n sandbox2 get secret
NAME                  TYPE                                  DATA   AGE
sandbox2-ca-tls       kubernetes.io/tls                     3      8m14s
sandbox2-client-tls   kubernetes.io/tls                     3      48s
sandbox2-server-tls   kubernetes.io/tls                     3      57s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validate the certificates against the CA:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ openssl verify -CAfile \
&amp;lt;(kubectl -n sandbox2 get secret sandbox2-ca-tls \
  -o jsonpath=&#39;{.data.ca\.crt}&#39; | base64 -d) \
&amp;lt;(kubectl -n sandbox2 get secret sandbox2-server-tls \
  -o jsonpath=&#39;{.data.tls\.crt}&#39; | base64 -d)
/proc/self/fd/18: OK

$ openssl verify -CAfile \
&amp;lt;(kubectl -n sandbox2 get secret sandbox2-ca-tls \
  -o jsonpath=&#39;{.data.ca\.crt}&#39; | base64 -d) \
&amp;lt;(kubectl -n sandbox2 get secret sandbox2-client-tls \
  -o jsonpath=&#39;{.data.tls\.crt}&#39; | base64 -d)
/proc/self/fd/18: OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Validate the Client / Server authentication&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Run an &lt;code&gt;openssl&lt;/code&gt; server as a background process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;touch test.txt

openssl s_server \
  -cert &amp;lt;(kubectl -n sandbox2 get secret sandbox2-server-tls -o jsonpath=&#39;{.data.tls\.crt}&#39; | base64 -d) \
  -key &amp;lt;(kubectl -n sandbox2 get secret sandbox2-server-tls -o jsonpath=&#39;{.data.tls\.key}&#39; | base64 -d) \
  -CAfile &amp;lt;(kubectl -n sandbox2 get secret sandbox2-ca-tls -o jsonpath=&#39;{.data.ca\.crt}&#39; | base64 -d) \
  -WWW -port 12345  \
  -verify_return_error -Verify 1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run an &lt;code&gt;openssl&lt;/code&gt; client test:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;look for &lt;code&gt;HTTP/1.0 200 ok&lt;/code&gt; in the client output.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo -e &#39;GET /test.txt HTTP/1.1\r\n\r\n&#39; | \
  openssl s_client \
  -cert &amp;lt;(kubectl -n sandbox2 get secret sandbox2-client-tls -o jsonpath=&#39;{.data.tls\.crt}&#39; | base64 -d) \
  -key &amp;lt;(kubectl -n sandbox2 get secret sandbox2-client-tls -o jsonpath=&#39;{.data.tls\.key}&#39; | base64 -d) \
  -CAfile &amp;lt;(kubectl -n sandbox2 get secret sandbox2-client-tls -o jsonpath=&#39;{.data.ca\.crt}&#39; | base64 -d) \
  -connect localhost:12345 -quiet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stop the background process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kill %1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Congratulations, you&amp;rsquo;ve now created a pair of certificates signed by the same CA that can be used for client/server authentication.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Creating self signed certificates is now officially easy. You can use &lt;a href=&#34;https://github.com/paulczar/omgwtfssl&#34;&gt;omgwtfssl&lt;/a&gt; locally, or &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt; in your Kubernetes cluster. Either way you get cheap and easy self signed certificates for testing. Obviously you should use real certificates in production, in which case you would still be able to use &lt;a href=&#34;https://cert-manager.io/&#34;&gt;cert-manager&lt;/a&gt;.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Securing Docker with TLS certificates</title>
      <link>https://tech.paulcz.net/blog/secure-docker-with-tls/</link>
      <pubDate>Sun, 03 Jan 2016 14:44:30 -0600</pubDate>
      
      <guid>https://tech.paulcz.net/blog/secure-docker-with-tls/</guid>
      <description>By default Docker (and by extension Docker Swarm) has no authentication or authorization on its API, relying instead on the filesystem security of its unix socket /var/run/docker.sock which by default is only accessible by the root user.
This is fine for the basic use case of the default behavior of only accessing the Docker API on the local machine via the socket as the root user. However if you wish to use the Docker API over TCP then you&amp;rsquo;ll want to secure it so that you don&amp;rsquo;t give out root access to anyone that happens to poke you on the TCP port.</description>
      <content>

&lt;p&gt;By default Docker (and by extension Docker Swarm) has no authentication or authorization on its API, relying instead on the filesystem security of its unix socket &lt;code&gt;/var/run/docker.sock&lt;/code&gt; which by default is only accessible by the root user.&lt;/p&gt;

&lt;p&gt;This is fine for the basic use case of the default behavior of only accessing the Docker API on the local machine via the socket as the root user. However if you wish to use the Docker API over TCP then you&amp;rsquo;ll want to secure it so that you don&amp;rsquo;t give out root access to anyone that happens to poke you on the TCP port.&lt;/p&gt;

&lt;p&gt;Docker supports using TLS certificates (both on the server and the client) to provide proof of identity. When set up correctly it will only allow clients/servers with a certificate signed by a specific CA to talk to eachother. While not providing fine grained access permissions it does at least allow us to listen on a TCP socket and restrict access with a bonus of also providing encryption.&lt;/p&gt;

&lt;p&gt;Here I will detail what is required to secure Docker (and in turn Docker Swarm) running on a &lt;a href=&#34;http://coreos.com/&#34;&gt;CoreOS&lt;/a&gt; server. I will assume you already have a &lt;a href=&#34;http://coreos.com/&#34;&gt;CoreOS&lt;/a&gt; server running as described in my Docker Swarm &lt;a href=&#34;http://tech.paulcz.net/2016/01/running-ha-docker-swarm/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are only interested in securing Docker itself and not Docker Swarm then this should apply to any server with Docker installed that uses systemd.  Even on systems without systemd it should provide enough details to secure Docker.&lt;/p&gt;

&lt;h2 id=&#34;creating-certificates&#34;&gt;Creating Certificates&lt;/h2&gt;

&lt;p&gt;I will offer two methods to create the certificates, the first by using &lt;code&gt;openssl&lt;/code&gt; to create a CA and then sign a key/cert pair, the second by using the &lt;a href=&#34;https://hub.docker.com/r/paulczar/omgwtfssl/&#34;&gt;paulczar/omgwtfssl&lt;/a&gt; Docker Image which automates the certificate creation process.&lt;/p&gt;

&lt;p&gt;Either way you&amp;rsquo;ll want to start off by creating directories for both the server and client certificate sets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /etc/docker/ssl
$ mkdir -p ~/.docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;For this example we&amp;rsquo;re creating the keys and certificates on the server itself, ideally you would do this on your laptop or via configuration management and never store the CA key on a public server.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;openssl&#34;&gt;OpenSSL&lt;/h3&gt;

&lt;p&gt;First run &lt;code&gt;openssl&lt;/code&gt; to create and sign a CA key and certificate and copy the CA certificate into &lt;code&gt;/etc/docker/ssl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl genrsa -out ~/.docker/ca-key.pem 2048
.+++
..........................................................................................................+++
e is 65537 (0x10001)

$ openssl req -x509 -new -nodes -key ~/.docker/ca-key.pem \
    -days 10000 -out ~/.docker/ca.pem -subj &#39;/CN=docker-CA&#39;

$ ls ~/.docker/
ca-key.pem  ca.pem

$ sudo cp ~/.docker/ca.pem /etc/docker/ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we&amp;rsquo;ll need an openssl configuration file for the Docker client &lt;code&gt;~/.docker/openssl.cnf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Followed by a configuration file for the Docker server &lt;code&gt;/etc/docker/ssl/openssl.cnf&lt;/code&gt;.  Add any DNS or IPs that you might use to access the Docker Server with, this is critical as the Golang SSL libraries are very strict:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = docker.local
IP.1 = 172.17.8.101
IP.2 = 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next create and sign a certificate for the client:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl genrsa -out ~/.docker/key.pem 2048
....................................+++
.............+++
e is 65537 (0x10001)

$ openssl req -new -key ~/.docker/key.pem -out ~/.docker/cert.csr \
    -subj &#39;/CN=docker-client&#39; -config ~/.docker/openssl.cnf

$ openssl x509 -req -in ~/.docker/cert.csr -CA ~/.docker/ca.pem \
    -CAkey ~/.docker/ca-key.pem -CAcreateserial \
    -out ~/.docker/cert.pem -days 365 -extensions v3_req \
    -extfile ~/.docker/openssl.cnf
Signature ok
subject=/CN=docker-client
Getting CA Private Key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then do the same for the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo openssl genrsa -out /etc/docker/ssl/key.pem 2048
................................................................................+++
....................................+++
e is 65537 (0x10001)

$ sudo openssl req -new -key /etc/docker/ssl/key.pem \
    -out /etc/docker/ssl/cert.csr \
    -subj &#39;/CN=docker-server&#39; -config /etc/docker/ssl/openssl.cnf

$ sudo openssl x509 -req -in /etc/docker/ssl/cert.csr -CA ~/.docker/ca.pem \
    -CAkey ~/.docker/ca-key.pem -CAcreateserial \
    -out /etc/docker/ssl/cert.pem -days 365 -extensions v3_req \
    -extfile /etc/docker/ssl/openssl.cnf
Signature ok
subject=/CN=docker-client
Getting CA Private Key
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;omgwtfssl&#34;&gt;OMGWTFSSL&lt;/h3&gt;

&lt;p&gt;If you want to skip manually creating the certificates you can use the &lt;a href=&#34;https://hub.docker.com/r/paulczar/omgwtfssl/&#34;&gt;paulczar/omgwtfssl&lt;/a&gt; image which is a small (&amp;lt; 10mb) Docker image built specifically for creating certificates for situations like this.&lt;/p&gt;

&lt;p&gt;First we&amp;rsquo;ll create our client certs and use a docker volume binding to put the CA and certs into &lt;code&gt;~/.docker&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -v $(pwd)/.docker:/certs \
    paulczar/omgwtfssl
----------------------------
| OMGWTFSSL Cert Generator |
----------------------------

--&amp;gt; Certificate Authority
====&amp;gt; Using existing CA Key ca-key.pem
====&amp;gt; Using existing CA Certificate ca.pem
====&amp;gt; Generating new config file openssl.cnf
====&amp;gt; Generating new SSL KEY key.pem
Generating RSA private key, 2048 bit long modulus
.............+++
..........+++
e is 65537 (0x10001)
====&amp;gt; Generating new SSL CSR key.csr
====&amp;gt; Generating new SSL CERT cert.pem
Signature ok
subject=/CN=example.com
Getting CA Private Key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we&amp;rsquo;ll take ownership of them back from root (because of the docker volume binding) and then create the server certificates using the same CA using a second volume binding to &lt;code&gt;/etc/docker/ssl&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Since this is a server certificate we need to pass the IP and DNS that the server may respond to via the -e command line arguments.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cp ~/.docker/ca.pem /etc/docker/ssl/ca.pem
$ chown -R $USER ~/.docker
$ docker run --rm -v /etc/docker/ssl:/server \
    -v $(pwd)/.docker:/certs \
    -e SSL_IP=127.0.0.1,172.17.8.101 \
    -e SSL_DNS=docker.local -e SSL_KEY=/server/key.pem \
    -e SSL_CERT=/server/cert.pem paulczar/omgwtfssl
----------------------------
| OMGWTFSSL Cert Generator |
----------------------------

--&amp;gt; Certificate Authority
====&amp;gt; Using existing CA Key ca-key.pem
====&amp;gt; Using existing CA Certificate ca.pem
====&amp;gt; Generating new config file openssl.cnf
====&amp;gt; Generating new SSL KEY /server/key.pem
Generating RSA private key, 2048 bit long modulus
.................................+++
..................+++
e is 65537 (0x10001)
====&amp;gt; Generating new SSL CSR key.csr
====&amp;gt; Generating new SSL CERT /server/cert.pem
Signature ok
subject=/CN=example.com
Getting CA Private Key
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-the-tls-certificates-with-docker&#34;&gt;Using the TLS certificates with Docker&lt;/h2&gt;

&lt;p&gt;Now we have our TLS certificates created and in the correct locations you need to tell Docker to use the TLS certificate and also verify the client.  You do this by creating a drop in systemd unit to modify the existing Docker systemd unit.&lt;/p&gt;

&lt;p&gt;Create the file &lt;code&gt;custom.conf&lt;/code&gt; in &lt;code&gt;/etc/systemd/system/docker.service.d/&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you want to restrict local users from using the docker unix socket remove the second -H command line option, if you already have a custom drop in unit you can add the -H and &amp;ndash;tls* arguments to it.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Service]
Environment=&amp;quot;DOCKER_OPTS=-H=0.0.0.0:2376 -H unix:///var/run/docker.sock --tlsverify --tlscacert=/etc/docker/ssl/ca.pem --tlscert=/etc/docker/ssl/cert.pem --tlskey=/etc/docker/ssl/key.pem&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reload systemd and the Docker service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo systemctl daemon-reload
$ sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when you try to access Docker via the TCP port you should get a TLS error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H tcp://127.0.0.1:2376 info
Get http://127.0.0.1:2376/v1.21/containers/json: malformed HTTP response &amp;quot;\x15\x03\x01\x00\x02\x02&amp;quot;.
* Are you trying to connect to a TLS-enabled daemon without TLS?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because the Docker client does not know to use TLS to communicate with the server.  We can set some environment variables to enable TLS for the client and use the client key we created:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export DOCKER_HOST=tcp://127.0.0.1:2376
$ export DOCKER_TLS_VERIFY=1
$ export DOCKER_CERT_PATH=~/.docker
$ docker info
docker info
Containers: 0
Images: 0
Server Version: 1.9.1
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 4.3.3-coreos
Operating System: CoreOS 899.1.0
CPUs: 1
Total Memory: 997.4 MiB
Name: core-01
ID: RGVQ:VDUC:Z5LU:IE7I:J6UJ:TFBJ:SSCO:EWG2:QKAW:5FY6:EIAV:MROK
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-the-tls-certificates-with-docker-swarm&#34;&gt;Using the TLS certificates with Docker Swarm&lt;/h2&gt;

&lt;p&gt;To secure Docker Swarm using these TLS certificates you will need to create TLS certificate/key pairs for each server using the same CA.&lt;/p&gt;

&lt;p&gt;to add some arguments to the &lt;code&gt;docker run&lt;/code&gt; command that you start Swarm Manager with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d --name swarm-manager \
    -v /etc/docker/ssl:/etc/docker/ssl \
    --net=host swarm:latest manage \
    --tlsverify \
    --tlscacert=/etc/docker/ssl/ca.pem \
    --tlscert=/etc/docker/ssl/cert.pem \
    --tlskey=/etc/docker/ssl/key.pem \
    etcd://127.0.0.1:2379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which you can then access using the docker client:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export DOCKER_HOST=tcp://127.0.0.1:2375
$ export DOCKER_TLS_VERIFY=1
$ export DOCKER_CERT_PATH=~/.docker

$ docker info
Containers: 6
Images: 5
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 3
 core-01: 172.17.8.101:2376
  └ Status: Healthy
  └ Containers: 2
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.023 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.3.3-coreos, operatingsystem=CoreOS 899.1.0, storagedriver=overlay
 core-02: 172.17.8.102:2376
  └ Status: Healthy
  └ Containers: 2
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.023 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.3.3-coreos, operatingsystem=CoreOS 899.1.0, storagedriver=overlay
 core-03: 172.17.8.103:2376
  └ Status: Healthy
  └ Containers: 2
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.023 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.3.3-coreos, operatingsystem=CoreOS 899.1.0, storagedriver=overlay
CPUs: 3
Total Memory: 3.068 GiB
Name: core-01
&lt;/code&gt;&lt;/pre&gt;
</content>
    </item>
    
  </channel>
</rss>