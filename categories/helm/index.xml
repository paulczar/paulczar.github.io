<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>helm on Paul Czarkowski</title>
    <link>https://tech.paulcz.net/categories/helm/</link>
    <description>Recent content in helm on Paul Czarkowski</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tech.paulcz.net/categories/helm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Creating a Helm Chart Repository - Part 1</title>
      <link>https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-1/</link>
      <pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-1/</guid>
      <description>Note: If this topic has peaked your interest, you can join me for a Webinar on August 15 where I&amp;rsquo;ll dive deep into Cloud Native Operations with Kubernetes and CI/CD Pipelines.
 Introduction Welcome to a three part blog series on Creating a Helm Chart Repository. In part 1 I will demonstrate creating a Helm chart repository using GitHub and GitHub Pages. In part 2 I will add Automation to automatically update the repository, and in part 3 I will add testing for changes to the charts themselves.</description>
      <content>

&lt;blockquote&gt;
&lt;p&gt;Note: If this topic has peaked your interest, you can join me for a Webinar on August 15 where I&amp;rsquo;ll dive deep into &lt;a href=&#34;https://content.pivotal.io/webinars/aug-15-cloud-native-operations-with-kubernetes-and-ci-cd-webinar?utm_campaign=cno-k8s-ci-cd-q319&amp;amp;utm_source=blog&amp;amp;utm_medium=website&#34;&gt;Cloud Native Operations with Kubernetes and CI/CD Pipelines&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Welcome to a three part blog series on Creating a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Repository. In &lt;strong&gt;part 1&lt;/strong&gt; I will demonstrate creating a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; chart repository using &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; and &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages. In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-2&#34;&gt;part 2&lt;/a&gt; I will add Automation to automatically update the repository, and in &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-3&#34;&gt;part 3&lt;/a&gt; I will add testing for changes to the charts themselves.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re into Videos, I walked JJ through starting with Helm from scratch all the way to creating a Helm Repo and CI/CD.  &lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/xn63krHJNKI&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Helm is the defacto tool for packaging, sharing, and running Kubernetes Manifests. I&amp;rsquo;m going to assume you know the basics of &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; and have used it before. There&amp;rsquo;s plenty of great introductory topics around.&lt;/p&gt;

&lt;p&gt;You can host and share &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts (packages) via a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Repository which is effectively a static website with an &lt;code&gt;index.yaml&lt;/code&gt; providing metadata and links to the &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Packages.&lt;/p&gt;

&lt;p&gt;This makes hosting a repository perfectly suited to running in &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages, s3, google cloud storage, etc. I like to use &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages as it allows your source code and repo to live effectively in the same place.&lt;/p&gt;

&lt;p&gt;I will walk you through creating a new &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Project hosting multiple &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; charts and demonstrate how to set up Continuous Integration with CircleCI to automatically test and publish new changes to your &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: While I would usually use &lt;a href=&#34;https://concourse-ci.org/&#34;&gt;Concourse CI&lt;/a&gt; for my CI workflows, I wanted to &lt;em&gt;only&lt;/em&gt; use managed services and I chose Circle as that is already commonly used in the Helm community.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;create-a-new-github-https-github-com-repository&#34;&gt;Create a new &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Repository&lt;/h2&gt;

&lt;p&gt;Log into &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; and &lt;a href=&#34;https://github.com/new&#34;&gt;create a new repository&lt;/a&gt; called &lt;code&gt;my-helm-charts&lt;/code&gt;. I chose to have &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; create it as with an Apache2 License.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./github-new-repo.png&#34; alt=&#34;Creating new repo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can now clone down this repository and get to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone git@github.com:paulczar/my-helm-charts.git
Cloning into &#39;my-helm-charts&#39;...
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (4/4), 4.52 KiB | 4.52 MiB/s, done.

$ cd my-helm-charts

$ tree
.
├── LICENSE
└── README.md

0 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see we have a default LICENSE file and a default README.md, we can leave them alone for now. Your next step is to create a couple of &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; charts. Since this is purely for demonstration purposes they don&amp;rsquo;t have to be overly functional charts which means we can just use the default boilerplate created by &lt;code&gt;helm create&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You do have &lt;a href=&#34;https://github.com/helm/helm#install&#34;&gt;helm&lt;/a&gt; installed right?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir charts

$ [Helm](https://helm.sh) create charts/app1
Creating charts/app1

$ [Helm](https://helm.sh) create charts/app2
Creating charts/app2

$ tree
.
├── charts
│   ├── app1
│   │   ├── charts
│   │   ├── Chart.yaml
│   │   ├── templates
│   │   │   ├── deployment.yaml
│   │   │   ├── _helpers.tpl
│   │   │   ├── ingress.yaml
│   │   │   ├── NOTES.txt
│   │   │   ├── service.yaml
│   │   │   └── tests
│   │   │       └── test-connection.yaml
│   │   └── values.yaml
│   └── app2
│       ├── charts
│       ├── Chart.yaml
│       ├── templates
│       │   ├── deployment.yaml
│       │   ├── _helpers.tpl
│       │   ├── ingress.yaml
│       │   ├── NOTES.txt
│       │   ├── service.yaml
│       │   └── tests
│       │       └── test-connection.yaml
│       └── values.yaml
├── LICENSE
└── README.md

9 directories, 18 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push these changes to git:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &amp;quot;.deploy&amp;quot; &amp;gt;&amp;gt; .gitignore

$ git add .

$ git commit -m &#39;Initial Commit&#39;
[master 2172141] Initial Commit
 18 files changed, 524 insertions(+)
...
...

$ git push origin master
Enumerating objects: 27, done.
Counting objects: 100% (27/27), done.
Delta compression using up to 4 threads
Compressing objects: 100% (24/24), done.
Writing objects: 100% (26/26), 4.72 KiB | 536.00 KiB/s, done.
Total 26 (delta 8), reused 0 (delta 0)
remote: Resolving deltas: 100% (8/8), done.
To github.com:paulczar/my-helm-charts.git
   abdcced..2172141  master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publish-your-helm-https-helm-sh-repository&#34;&gt;Publish your &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Repository&lt;/h2&gt;

&lt;h3 id=&#34;prepare-github-https-github-com-pages&#34;&gt;Prepare &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to use a combination of &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages and releases to host our &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Repository. Therefore we need to ensure we have &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages enabled on the git repo and to create an empty &lt;code&gt;gh-pages&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;You can create an empty &lt;code&gt;gh-pages&lt;/code&gt; branch by creating an orphan branch like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout --orphan gh-pages
Switched to a new branch &#39;gh-pages&#39;

$ rm -rf charts

$ git add . --all

$ git commit -m &#39;initial gh-pages&#39;
git commit -m &#39;initial gh-pages&#39;
[gh-pages a9ce382] initial gh-pages
 18 files changed, 524 deletions(-)
...
...

$ git push origin gh-pages
Enumerating objects: 3, done.
...
...
To github.com:paulczar/my-helm-charts.git
 * [new branch]      gh-pages -&amp;gt; gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next check that &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages is enabled by clicking on your git repo settings in GitHub:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./github-pages.png&#34; alt=&#34;github repo settings&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: I have a custom domain set up, your URL will probably be username.github.io/my-helm-charts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After a few minutes you should have a default rendering on your README.md at the provided URL:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./default-gh-pages.png&#34; alt=&#34;default [GitHub](https://github.com) ages&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;introducing-chart-releaser&#34;&gt;Introducing chart-releaser&lt;/h3&gt;

&lt;p&gt;You could use a combination of &lt;code&gt;helm package&lt;/code&gt; and &lt;code&gt;helm repo&lt;/code&gt; commands to construct your &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; repository by hand, or you can simplify your life by using &lt;code&gt;chart-releaser&lt;/code&gt; which will not only create your packages, but will upload them as binaries into an appropriately versioned &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Release.&lt;/p&gt;

&lt;p&gt;Download chart-releaser for your architecture [here].&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: I&amp;rsquo;m doing this on a linux machine, so you may need to update the commands below for Mac OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a new terminal download and unpackage it, moving it to an executable path:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /tmp
$ curl -sSL https://github.com/helm/chart-releaser/releases/download/v0.2.1/chart-releaser_0.2.1_linux_amd64.tar.gz | tar xzf -

$ mv cr ~/bin/cr

$ cr help
Create [Helm](https://helm.sh) chart repositories on [GitHub](https://github.com) Pages by uploading Chart packages
and Chart metadata to [GitHub](https://github.com) Releases and creating a suitable index file

Usage:
  cr [command]

Available Commands:
  help        Help about any command
  index       Update Helm repo index.yaml for the given GitHub repo
  upload      Upload Helm chart packages to GitHub Releases
  version     Print version information

Flags:
      --config string   Config file (default is $HOME/.cr.yaml)
  -h, --help            help for cr

Use &amp;quot;cr [command] --help&amp;quot; for more information about a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two commands we care about &lt;code&gt;cr index&lt;/code&gt; and &lt;code&gt;cr upload&lt;/code&gt;, the first will create an appropriate &lt;code&gt;index.yaml&lt;/code&gt; and the second will upload the packages to &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Releases. In order to do the latter you&amp;rsquo;ll need to pass it in a &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Token so that it can use the &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; APIs.&lt;/p&gt;

&lt;p&gt;In your browser go to your &lt;a href=&#34;https://github.com/settings/tokens&#34;&gt;github developer settings&lt;/a&gt; and create a new personal access token.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./personal-access-token.png&#34; alt=&#34;create personal access token&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Create an environment variable (or a &lt;code&gt;~/.cr.yaml&lt;/code&gt; config file) containing the access token:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pro-tip: put an additional space in your command right before &lt;code&gt;export&lt;/code&gt; and it won&amp;rsquo;t be saved to your command history.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$  export CH_TOKEN=c4a4ed6ab91a246572b0c46c19c630ccadc1049
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-and-upload-helm-https-helm-sh-packages&#34;&gt;Create and Upload &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Packages&lt;/h3&gt;

&lt;p&gt;Your next step is to create and upload the packages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ Helm package charts/{app1,app2} --destination .deploy
Successfully packaged chart and saved it to: .deploy/app1-0.1.0.tgz
Successfully packaged chart and saved it to: .deploy/app2-0.1.0.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;cr upload&lt;/code&gt; to create releases and upload the packages, note if it runs correctly there&amp;rsquo;s no output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cr upload -o paulczar -r my-helm-charts -p .deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check your &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; repository now has a releases page with two releases:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./github-releases&#34; alt=&#34;github releases page&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;create-and-upload-index-file-to-github-https-github-com-pages&#34;&gt;Create and upload index file to &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages&lt;/h3&gt;

&lt;p&gt;Checkout your &lt;code&gt;gh-pages&lt;/code&gt; branch and run &lt;code&gt;cr index&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout gh-pages

$ cr index -i ./index.yaml -p .deploy --owner paulczar --repo my-helm-charts
====&amp;gt; UpdateIndexFile new index at ./index.yaml
====&amp;gt; Found app1-0.1.0.tgz
====&amp;gt; Extracting chart metadata from .deploy/app1-0.1.0.tgz
====&amp;gt; Calculating Hash for .deploy/app1-0.1.0.tgz
====&amp;gt; Found app2-0.1.0.tgz
====&amp;gt; Extracting chart metadata from .deploy/app2-0.1.0.tgz
====&amp;gt; Calculating Hash for .deploy/app2-0.1.0.tgz
--&amp;gt; Updating index ./index.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There should now be a &lt;code&gt;index.yaml&lt;/code&gt; file containing the details of your &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; packages and the path to their archive:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat index.yaml
apiVersion: v1
entries:
  app1:
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: &amp;quot;2019-07-03T13:03:06.139332963-05:00&amp;quot;
    description: A Helm chart for Kubernetes
    digest: 48cf831b72febeac2860a0be372094250aea68a9c76147c028085c8802dd48ec
    name: app1
    urls:
    - https://github.com/paulczar/my-helm-charts/releases/download/app1-0.1.0/app1-0.1.0.tgz
    version: 0.1.0
  app2:
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: &amp;quot;2019-07-03T13:03:07.301308677-05:00&amp;quot;
    description: A Helm chart for Kubernetes
    digest: 64b00fc4804aba524201f64e78ee22ad8e61d0923424f8e24e8b70befed88141
    name: app2
    urls:
    - https://github.com/paulczar/my-helm-charts/releases/download/app2-0.1.0/app2-0.1.0.tgz
    version: 0.1.0
generated: &amp;quot;2019-07-03T13:03:05.685803874-05:00&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commit this to git and then wait a few minutes and check that it exists in your &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages url:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add index.yaml

$ git commit -m &#39;release 0.1.0&#39;
[gh-pages 696df18] release 0.1.0
 1 file changed, 23 insertions(+)
 create mode 100644 index.yaml

$ git push origin gh-pages
...
To github.com:paulczar/my-helm-charts.git
   75f1fe8..696df18  gh-pages -&amp;gt; gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check it exists in &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;github-pages-index-yaml.png&#34; alt=&#34;github pages index.yaml&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;test-your-new-helm-https-helm-sh-repostiory&#34;&gt;Test your new &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Repostiory&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: To do this you&amp;rsquo;ll need a Kubernetes cluster with Helm&amp;rsquo;s tiller installed, but you already know how to do that right?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ helm repo add my-helm-charts https://tech.paulcz.net/my-helm-charts
&amp;quot;my-helm-charts&amp;quot; has been added to your repositories

$ helm install --name test --namespace test my-helm-charts/app1
NAME:   test
LAST DEPLOYED: Wed Jul  3 13:17:32 2019
NAMESPACE: test
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Deployment
NAME       READY  UP-TO-DATE  AVAILABLE  AGE
test-app1  0/1    1           0          0s

==&amp;gt; v1/Pod(related)
NAME                        READY  STATUS             RESTARTS  AGE
test-app1-7b575d95f6-zhlh2  0/1    ContainerCreating  0         0s

==&amp;gt; v1/Service
NAME       TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)  AGE
test-app1  ClusterIP  10.100.200.213  &amp;lt;none&amp;gt;       80/TCP   0s


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace test -l &amp;quot;app.kubernetes.io/name=app1,app.kubernetes.io/instance=test&amp;quot; -o jsonpath=&amp;quot;{.items[0].metadata.name}&amp;quot;)
  echo &amp;quot;Visit http://127.0.0.1:8080 to use your application&amp;quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check that it deployed ok:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n test get all
NAME                             READY   STATUS    RESTARTS   AGE
pod/test-app1-7b575d95f6-zhlh2   1/1     Running   0          42m

NAME                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
service/test-app1   ClusterIP   10.100.200.213   &amp;lt;none&amp;gt;        80/TCP    42m

NAME                        READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/test-app1   1/1     1            1           42m

NAME                                   DESIRED   CURRENT   READY   AGE
replicaset.apps/test-app1-7b575d95f6   1         1         1       42m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm delete --purge test
release &amp;quot;test&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update-the-readme-md-with-instructions-on-using&#34;&gt;Update the README.md with instructions on using&lt;/h3&gt;

&lt;p&gt;switch back to your &lt;code&gt;master&lt;/code&gt; brach:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit your README.md to provide details on how to use charts from your repository:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# My [Helm](https://helm.sh) Charts

This repository contains [Helm](https://helm.sh) charts for various projects

* [Application 1](charts/app1/)
* [Application 2](charts/app2/)

## Installing Charts from this Repository

Add the Repository to Helm:

    helm repo add my-helm-charts https://tech.paulcz.net/my-helm-charts

Install Application 1:

    helm install my-helm-charts/app1

Install Application 2:

    helm install my-helm-charts/app2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commit the change up to GitHub:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add README.md
$ git commit -m &#39;update readme with instructions&#39;
$ git push origin master
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s the end of &lt;strong&gt;Part 1&lt;/strong&gt; of this three part series. In future posts I will demonstrate adding &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-2&#34;&gt;automation&lt;/a&gt; and &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-3&#34;&gt;testing&lt;/a&gt; to this &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; chart repository.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Creating a Helm Chart Repository - Part 2</title>
      <link>https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-2/</link>
      <pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-2/</guid>
      <description>Introduction Welcome to a three part blog series on Creating a Helm Chart Repository. In part 1 of this series I demonstrated creating a Helm chart repository using GitHub and GitHub Pages. In this part 2 I will add Automation to automatically update the repository, and in part 2 I will add testing for changes to the charts themselves.
 If you&amp;rsquo;re into Videos, I walked JJ through starting with Helm from scratch all the way to creating a Helm Repo and CI/CD.</description>
      <content>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Welcome to a three part blog series on Creating a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Repository. In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-1&#34;&gt;part 1&lt;/a&gt; of this series I demonstrated creating a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; chart repository using &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; and &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages. In this &lt;strong&gt;part 2&lt;/strong&gt; I will add Automation to automatically update the repository, and in &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-3&#34;&gt;part 2&lt;/a&gt; I will add testing for changes to the charts themselves.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re into Videos, I walked JJ through starting with Helm from scratch all the way to creating a Helm Repo and CI/CD.  &lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/xn63krHJNKI&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;use-circle-ci-to-automate-helm-https-helm-sh-chart-updates&#34;&gt;Use Circle CI to automate &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Updates&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: While I would usually use &lt;a href=&#34;https://concourse-ci.org/&#34;&gt;Concourse CI&lt;/a&gt; for my CI workflows, I wanted to &lt;em&gt;only&lt;/em&gt; use managed services and I chose Circle as that is already commonly used in the Helm community. It would be trivial to whip up a Concourse Pipeline to do the same thing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now that we&amp;rsquo;ve successfully created a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Repostiory using &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; and &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; pages we can move on to adding some Automation so that our Chart Repository is updated any time we push changes up to our master branch.&lt;/p&gt;

&lt;p&gt;Its pretty easy to create a new Circle CI account. You simply go to their website and hit &lt;a href=&#34;https://circleci.com/signup/&#34;&gt;sign-up&lt;/a&gt;, it will ask you to log using &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt;Oauth2 and once you&amp;rsquo;ve given it access to your repositories you are good to go.&lt;/p&gt;

&lt;p&gt;Once logged in you need to hit the &lt;strong&gt;ADD Projects&lt;/strong&gt; menu item and hit the &lt;strong&gt;set up project&lt;/strong&gt; button next to &lt;strong&gt;my-helm-charts&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;circle-add-project.png&#34; alt=&#34;add project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can leave the defaults and just go down and click the &lt;strong&gt;Start Building&lt;/strong&gt; button.&lt;/p&gt;

&lt;p&gt;It will attempt to run and fail because you don&amp;rsquo;t have a &lt;code&gt;.circleci/config.yml&lt;/code&gt; file in your repo yet. We&amp;rsquo;ll create that soon.&lt;/p&gt;

&lt;p&gt;Before we do that though we need to create a private key for Circle CI with write access to our project. Hit the &lt;strong&gt;settings&lt;/strong&gt; button on the top right of the &lt;strong&gt;Workflows -&amp;gt; username -&amp;gt; my-helm-charts&lt;/strong&gt; screen tat looks like a little cog.&lt;/p&gt;

&lt;p&gt;From here you want to hit SSH permissions and hit &lt;strong&gt;Checkout SSH Keys&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;There should be a &lt;strong&gt;Add user key&lt;/strong&gt; section with a button that says &lt;strong&gt;Authorize with GitHub&lt;/strong&gt;, hit that button. To be extra certain it loads the same page and you need to click the &lt;strong&gt;Create and add [username] user key&lt;/strong&gt; which will create a key and pass the public key off to github.&lt;/p&gt;

&lt;p&gt;On that same &lt;strong&gt;settings&lt;/strong&gt; page you need to add some environment variables:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./circle-env-vars.png&#34; alt=&#34;circle env vars&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now its time to set up our Automation.&lt;/p&gt;

&lt;h3 id=&#34;create-circle-ci-config-for-uploading-new-packages&#34;&gt;Create Circle CI config for uploading new packages&lt;/h3&gt;

&lt;p&gt;Create a new directory &lt;code&gt;.circleci&lt;/code&gt; and a file inside that called &lt;code&gt;config.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir .circleci
$ touch .circleci/config.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write out the &lt;code&gt;config.yml&lt;/code&gt; file like so:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: this CircleCI config file creates two jobs, One to lint the shell scripts we&amp;rsquo;re about to create, the other to release charts and copy documentation into our &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; repo website. These tasks will run when code is pushed or merged into the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;circleci-config-yml-https-github-com-paulczar-my-helm-charts-blob-part-2-circleci-config-yml&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-2/.circleci/config.yml&#34;&gt;.circleci/config.yml&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: 2
jobs:
  lint-scripts:
    docker:
      - image: koalaman/shellcheck-alpine
    steps:
      - checkout
      - run:
          name: lint
          command: shellcheck -x .circleci/*.sh
  release-charts:
    machine: true
    steps:
      - checkout
      - run:
          command: |
            echo &amp;quot;export GIT_REPOSITORY_URL=$CIRCLE_REPOSITORY_URL&amp;quot; &amp;gt;&amp;gt; $BASH_ENV
            echo &amp;quot;export GIT_USERNAME=$CIRCLE_PROJECT_USERNAME&amp;quot; &amp;gt;&amp;gt; $BASH_ENV
            echo &amp;quot;export GIT_REPOSITORY_NAME=$CIRCLE_PROJECT_REPONAME&amp;quot; &amp;gt;&amp;gt; $BASH_ENV
            .circleci/install_tools.sh
            .circleci/release.sh

workflows:
  version: 2
  release:
    jobs:
      - lint-scripts
      - release-charts:
          filters:
            tags:
              ignore: /.*/
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We referenced two scripts in the &lt;code&gt;config.yml&lt;/code&gt; file, so we better create those. These scripts are a mix of ones that I have written, and have borrowed from &lt;a href=&#34;https://twitter.com/unguiculus&#34;&gt;Reinhard Nägele&lt;/a&gt; one of the main contributors to awesome tooling in the Helm Community as found &lt;a href=&#34;https://github.com/codecentric/helm-charts/blob/master/.circleci/release.sh&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s no surprise that these scripts came from &lt;a href=&#34;https://twitter.com/unguiculus&#34;&gt;Reinhard Nägele&lt;/a&gt;as he is a primary maintainer of both &lt;a href=&#34;https://github.com/helm/chart-testing&#34;&gt;chart-testing&lt;/a&gt; and &lt;a href=&#34;https://github.com/helm/chart-releaser&#34;&gt;chart-releaser&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;circleci-install-tools-sh-https-github-com-paulczar-my-helm-charts-blob-part-2-circleci-install-tools-sh&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-2/.circleci/install_tools.sh&#34;&gt;.circleci/install_tools.sh&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash

set -o errexit

readonly HELM_VERSION=2.13.1
readonly CHART_RELEASER_VERSION=0.1.4

echo &amp;quot;Installing Helm...&amp;quot;
curl -LO &amp;quot;https://kubernetes-helm.storage.googleapis.com/helm-v$HELM_VERSION-linux-amd64.tar.gz&amp;quot;
sudo mkdir -p &amp;quot;/usr/local/helm-v$HELM_VERSION&amp;quot;
sudo tar -xzf &amp;quot;helm-v$HELM_VERSION-linux-amd64.tar.gz&amp;quot; -C &amp;quot;/usr/local/helm-v$HELM_VERSION&amp;quot;
sudo ln -s &amp;quot;/usr/local/helm-v$HELM_VERSION/linux-amd64/helm&amp;quot; /usr/local/bin/helm
rm -f &amp;quot;helm-v$HELM_VERSION-linux-amd64.tar.gz&amp;quot;
helm init --client-only

echo &amp;quot;Installing chart-releaser...&amp;quot;
curl -LO &amp;quot;https://github.com/helm/chart-releaser/releases/download/v${CHART_RELEASER_VERSION}/chart-releaser_${CHART_RELEASER_VERSION}_Linux_x86_64.tar.gz&amp;quot;
sudo mkdir -p &amp;quot;/usr/local/chart-releaser-v$CHART_RELEASER_VERSION&amp;quot;
sudo tar -xzf &amp;quot;chart-releaser_${CHART_RELEASER_VERSION}_Linux_x86_64.tar.gz&amp;quot; -C &amp;quot;/usr/local/chart-releaser-v$CHART_RELEASER_VERSION&amp;quot;
sudo ln -s &amp;quot;/usr/local/chart-releaser-v$CHART_RELEASER_VERSION/chart-releaser&amp;quot; /usr/local/bin/chart-releaser
rm -f &amp;quot;chart-releaser_${CHART_RELEASER_VERSION}_Linux_x86_64.tar.gz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;circleci-release-sh-https-github-com-paulczar-my-helm-charts-blob-part-2-circleci-release-sh&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-2/.circleci/release.sh&#34;&gt;.circleci/release.sh&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

: &amp;quot;${CH_TOKEN:?Environment variable CH_TOKEN must be set}&amp;quot;
: &amp;quot;${GIT_REPOSITORY_URL:?Environment variable GIT_REPO_URL must be set}&amp;quot;
: &amp;quot;${GIT_USERNAME:?Environment variable GIT_USERNAME must be set}&amp;quot;
: &amp;quot;${GIT_EMAIL:?Environment variable GIT_EMAIL must be set}&amp;quot;
: &amp;quot;${GIT_REPOSITORY_NAME:?Environment variable GIT_REPOSITORY_NAME must be set}&amp;quot;

readonly REPO_ROOT=&amp;quot;${REPO_ROOT:-$(git rev-parse --show-toplevel)}&amp;quot;

main() {
    pushd &amp;quot;$REPO_ROOT&amp;quot; &amp;gt; /dev/null

    echo &amp;quot;Fetching tags...&amp;quot;
    git fetch --tags

    local latest_tag
    latest_tag=$(find_latest_tag)

    local latest_tag_rev
    latest_tag_rev=$(git rev-parse --verify &amp;quot;$latest_tag&amp;quot;)
    echo &amp;quot;$latest_tag_rev $latest_tag (latest tag)&amp;quot;

    local head_rev
    head_rev=$(git rev-parse --verify HEAD)
    echo &amp;quot;$head_rev HEAD&amp;quot;

    if [[ &amp;quot;$latest_tag_rev&amp;quot; == &amp;quot;$head_rev&amp;quot; ]]; then
        echo &amp;quot;No code changes. Nothing to release.&amp;quot;
        exit
    fi

    rm -rf .deploy
    mkdir -p .deploy

    echo &amp;quot;Identifying changed charts since tag &#39;$latest_tag&#39;...&amp;quot;

    local changed_charts=()
    readarray -t changed_charts &amp;lt;&amp;lt;&amp;lt; &amp;quot;$(git diff --find-renames --name-only &amp;quot;$latest_tag_rev&amp;quot; -- charts | cut -d &#39;/&#39; -f 2 | uniq)&amp;quot;

    if [[ -n &amp;quot;${changed_charts[*]}&amp;quot; ]]; then
        for chart in &amp;quot;${changed_charts[@]}&amp;quot;; do
            echo &amp;quot;Packaging chart &#39;$chart&#39;...&amp;quot;
            package_chart &amp;quot;charts/$chart&amp;quot;
        done

        release_charts
        sleep 5
        update_index
    else
        echo &amp;quot;Nothing to do. No chart changes detected.&amp;quot;
    fi

    popd &amp;gt; /dev/null
}

find_latest_tag() {
    if ! git describe --tags --abbrev=0 2&amp;gt; /dev/null; then
        git rev-list --max-parents=0 --first-parent HEAD
    fi
}

package_chart() {
    local chart=&amp;quot;$1&amp;quot;
    Helm dependency build &amp;quot;$chart&amp;quot;
    Helm package &amp;quot;$chart&amp;quot; --destination .deploy
}

release_charts() {
    chart-releaser upload -o &amp;quot;$GIT_USERNAME&amp;quot; -r &amp;quot;$GIT_REPOSITORY_NAME&amp;quot; -p .deploy
}

update_index() {
    chart-releaser index -o &amp;quot;$GIT_USERNAME&amp;quot; -r &amp;quot;$GIT_REPOSITORY_NAME&amp;quot; -p .deploy/index.yaml

    git config user.email &amp;quot;$GIT_EMAIL&amp;quot;
    git config user.name &amp;quot;$GIT_USERNAME&amp;quot;

    for file in charts/*/*.md; do
        if [[ -e $file ]]; then
            mkdir -p &amp;quot;.deploy/docs/$(dirname &amp;quot;$file&amp;quot;)&amp;quot;
            cp --force &amp;quot;$file&amp;quot; &amp;quot;.deploy/docs/$(dirname &amp;quot;$file&amp;quot;)&amp;quot;
        fi
    done

    git checkout gh-pages
    cp --force .deploy/index.yaml index.yaml

    if [[ -e &amp;quot;.deploy/docs/charts&amp;quot; ]]; then
        mkdir -p charts
        cp --force --recursive .deploy/docs/charts/* charts/
    fi

    git checkout master -- README.md

    if ! git diff --quiet; then
        git add .
        git commit --message=&amp;quot;Update index.yaml&amp;quot; --signoff
        git push &amp;quot;$GIT_REPOSITORY_URL&amp;quot; gh-pages
    fi
}

main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add these new files to git and push them up to the &lt;code&gt;master&lt;/code&gt; branch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add .

$ git status
On branch master
Your branch is up to date with &#39;origin/master&#39;.

Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

  new file:   .circleci/config.yml
  new file:   .circleci/install_tools.sh
  new file:   .circleci/release.sh

$ git commit -m &#39;add circle ci scripts&#39;

$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This push should kick off a Circle CI job which will hopefully pass (I usually get it wrong the first few times).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./circle-first-job.png&#34; alt=&#34;circle first job&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice there&amp;rsquo;s a failed job, that&amp;rsquo;s because when circleci sees the releases being updated it tries to run a job for the &lt;code&gt;gh-pages&lt;/code&gt; branch that doesn&amp;rsquo;t have a circle-ci config. We can use this sweet git trick to grab the one from the master branch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout gh-pages
$ git pull origin gh-pages
$ mkdir .circleci
$ git checkout master -- .circleci/config.yml
$ git add .circleci/config.yml
$ git commit -m &#39;add circleci config&#39;
$ git push origin gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;validate-the-release-of-new-charts&#34;&gt;Validate the release of new charts&lt;/h3&gt;

&lt;p&gt;So far we haven&amp;rsquo;t actually changed our &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts, so the automation hasn&amp;rsquo;t created a new release. We can change this by bumping the chart version of one of them.  Edit &lt;code&gt;./charts/app1/Chart.yaml&lt;/code&gt; and bump the version like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
appVersion: &amp;quot;1.0&amp;quot;
description: A Helm chart for Kubernetes
name: app1
version: 0.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push this change up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add .
$ git commit -m &#39;update app1 chart&#39;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see the new job show up in Circle and complete fairly quickly.&lt;/p&gt;

&lt;p&gt;Once the job has completed successfully you can check you now have a &lt;code&gt;myapp-0.1.1&lt;/code&gt; release in your &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt;repo and your &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; repository now has &lt;code&gt;myapp-0.1.1&lt;/code&gt; in its &lt;code&gt;index.yaml&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://tech.paulcz.net/my-helm-charts/index.yaml
apiVersion: v1
entries:
  app1:
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: &amp;quot;2019-07-03T23:16:21.087774995Z&amp;quot;
    description: A Helm chart for Kubernetes
    digest: 9fbf6f9d10fba82aa3b749875e137b283890136a7379efba2bbff0b645cb1c35
    name: app1
    urls:
    - https://github.com/paulczar/my-helm-charts/releases/download/app1-0.1.1/app1-0.1.1.tgz
    version: 0.1.1
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: &amp;quot;2019-07-03T23:16:21.376254864Z&amp;quot;
    description: A Helm chart for Kubernetes
    digest: 48cf831b72febeac2860a0be372094250aea68a9c76147c028085c8802dd48ec
    name: app1
    urls:
    - https://github.com/paulczar/my-helm-charts/releases/download/app1-0.1.0/app1-0.1.0.tgz
    version: 0.1.0
  app2:
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: &amp;quot;2019-07-03T23:16:21.22793015Z&amp;quot;
    description: Helm chart for Kubernetes
    digest: 64b00fc4804aba524201f64e78ee22ad8e61d0923424f8e24e8b70befed88141
    name: app2
    urls:
    - https://github.com/paulczar/my-helm-charts/releases/download/app2-0.1.0/app2-0.1.0.tgz
    version: 0.1.0
generated: &amp;quot;2019-07-03T23:16:20.624914794Z&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-1&#34;&gt;Part 1&lt;/a&gt; we created set of &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts managed in source control (GitHub) and in Part 2 we just added automation via CircleCI to automate building and deploying Chart packages to a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Repository hosted in &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; pages and &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt;releases.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-3&#34;&gt;Part 3&lt;/a&gt; we will add further automation to test for changes in those &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; charts and to pass them through rigorous testing before allowing them to be merged into the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Creating a Helm Chart Repository - Part 3</title>
      <link>https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-3/</link>
      <pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-3/</guid>
      <description>Introduction Welcome to a three part blog series on Creating a Helm Chart Repository. In part 1 of this series I demonstrated creating a Helm chart repository using GitHub and GitHub Pages. In part 2 I will add Automation to automatically update the repository, and in part 3 I will add testing for changes to the charts themselves.
 If you&amp;rsquo;re into Videos, I walked JJ through starting with Helm from scratch all the way to creating a Helm Repo and CI/CD.</description>
      <content>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Welcome to a three part blog series on Creating a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Repository. In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-1&#34;&gt;part 1&lt;/a&gt; of this series I demonstrated creating a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; chart repository using &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; and &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages. In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-2&#34;&gt;part 2&lt;/a&gt; I will add Automation to automatically update the repository, and in &lt;strong&gt;part 3&lt;/strong&gt; I will add testing for changes to the charts themselves.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re into Videos, I walked JJ through starting with Helm from scratch all the way to creating a Helm Repo and CI/CD.  &lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/xn63krHJNKI&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;use-circle-ci-to-test-helm-https-helm-sh-charts&#34;&gt;Use Circle CI to test &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Note - You could use any other CI system here, I chose Circle as it is easy to integrate with &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; and has a free tier. If you do use a different CI system the scripts should still work, but you&amp;rsquo;ll need to rewrite a config file suitable for your CI choice.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;introducing-chart-testing&#34;&gt;Introducing Chart Testing&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; community has built a tool very imaginitively named [Chart Testing]((&lt;a href=&#34;https://github.com/helm/chart-testing&#34;&gt;https://github.com/helm/chart-testing&lt;/a&gt;) specifically for testing &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; charts. Not only is it capable of linting and performing test installs of a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; chart, but its also designed to work within a monorepo and only test those charts that have changed.&lt;/p&gt;

&lt;p&gt;You can download and use &lt;a href=&#34;https://github.com/helm/chart-testing/releases&#34;&gt;Chart Testing&lt;/a&gt; locally, but really the power of it is using it in CI, so lets go straight to that.&lt;/p&gt;

&lt;h3 id=&#34;creat-a-chart-testing-script-and-update-circle-ci-config&#34;&gt;Creat a Chart Testing script and update Circle CI config&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: While I would usually use &lt;a href=&#34;https://concourse-ci.org/&#34;&gt;Concourse CI&lt;/a&gt; for my CI workflows, I wanted to &lt;em&gt;only&lt;/em&gt; use managed services and I chose Circle as that is already commonly used in the Helm community.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need to add a new script, a chart-testing config file, and update the Circle CI config file.&lt;/p&gt;

&lt;h4 id=&#34;circleci-config-yaml-https-github-com-paulczar-my-helm-charts-blob-part-2-circleci-config-yaml&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-2/.circleci/config.yaml&#34;&gt;./circleci/config.yaml&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Create two new jobs:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;These scripts and configs were heavily borrowed from &lt;a href=&#34;https://twitter.com/unguiculus&#34;&gt;Reinhard Nägele&lt;/a&gt; who is a primary maintainer of both &lt;a href=&#34;https://github.com/helm/chart-testing&#34;&gt;chart-testing&lt;/a&gt; and &lt;a href=&#34;https://github.com/helm/chart-releaser&#34;&gt;chart-releaser&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first job tells Chart Testing to lint the charts according to the &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Community &lt;a href=&#34;https://helm.sh/docs/chart_best_practices/&#34;&gt;Best Practices Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The second job tells Chart Testing to actually install and test the charts using KIND (Kubernetes IN Docker).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  lint-charts:
    docker:
      - image: gcr.io/kubernetes-charts-ci/test-image:v3.3.2
    steps:
      - checkout
      - run:
          name: lint
          command: |
            git remote add upstream https://github.com/paulczar/percona-helm-charts
            git fetch upstream master
            ct lint --config .circleci/ct.yaml

  install-charts:
    machine: true
    steps:
      - checkout
      - run:
          no_output_timeout: 12m
          command: .circleci/install_charts.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add a new workflow telling Circle to lint and test any changes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: it excludes the &lt;code&gt;master&lt;/code&gt; branch as we don&amp;rsquo;t want to try to retest charts as they&amp;rsquo;re merged in after successfully testing the new commit.:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  lint-and-install:
    jobs:
      - lint-scripts
      - lint-charts:
          filters:
            branches:
              ignore: master
            tags:
              ignore: /.*/
      - install-charts:
          requires:
            - lint-charts
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;circleci-ct-yaml-https-github-com-paulczar-my-helm-charts-blob-part-3-circleci-ct-yaml&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-3/.circleci/ct.yaml&#34;&gt;./circleci/ct.yaml&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This file provides configuration for Chart Testing. For now all we need is to tell it to provide &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; with a longer timeout:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;helm-extra-args: --timeout 600
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;circleci-kind-config-yaml-https-github-com-paulczar-my-helm-charts-blob-part-3-circleci-kind-config-yaml&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-3/.circleci/kind-config.yaml&#34;&gt;./circleci/kind-config.yaml&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This file provides a configuration for KIND to use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: Cluster
apiVersion: kind.sigs.k8s.io/v1alpha3
nodes:
  - role: control-plane
  - role: worker
  - role: worker
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;circleci-install-charts-sh-https-github-com-paulczar-my-helm-charts-blob-part-3-circleci-install-charts-sh&#34;&gt;&lt;a href=&#34;https://github.com/paulczar/my-helm-charts/blob/part-3/.circleci/install_charts.sh&#34;&gt;./circleci/install_charts.sh&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Finally this script will install KIND and will perform test installations for any changed &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

readonly CT_VERSION=v2.3.3
readonly KIND_VERSION=0.2.1
readonly CLUSTER_NAME=chart-testing
readonly K8S_VERSION=v1.14.0

run_ct_container() {
    echo &#39;Running ct container...&#39;
    docker run --rm --interactive --detach --network host --name ct \
        --volume &amp;quot;$(pwd)/.circleci/ct.yaml:/etc/ct/ct.yaml&amp;quot; \
        --volume &amp;quot;$(pwd):/workdir&amp;quot; \
        --workdir /workdir \
        &amp;quot;quay.io/helmpack/chart-testing:$CT_VERSION&amp;quot; \
        cat
    echo
}

cleanup() {
    echo &#39;Removing ct container...&#39;
    docker kill ct &amp;gt; /dev/null 2&amp;gt;&amp;amp;1

    echo &#39;Done!&#39;
}

docker_exec() {
    docker exec --interactive ct &amp;quot;$@&amp;quot;
}

create_kind_cluster() {
    echo &#39;Installing kind...&#39;

    curl -sSLo kind &amp;quot;https://github.com/kubernetes-sigs/kind/releases/download/$KIND_VERSION/kind-linux-amd64&amp;quot;
    chmod +x kind
    sudo mv kind /usr/local/bin/kind

    kind create cluster --name &amp;quot;$CLUSTER_NAME&amp;quot; --config .circleci/kind-config.yaml --image &amp;quot;kindest/node:$K8S_VERSION&amp;quot; --wait 60s

    docker_exec mkdir -p /root/.kube

    echo &#39;Copying kubeconfig to container...&#39;
    local kubeconfig
    kubeconfig=&amp;quot;$(kind get kubeconfig-path --name &amp;quot;$CLUSTER_NAME&amp;quot;)&amp;quot;
    docker cp &amp;quot;$kubeconfig&amp;quot; ct:/root/.kube/config

    docker_exec kubectl cluster-info
    echo

    docker_exec kubectl get nodes
    echo
}

install_local_path_provisioner() {
    docker_exec kubectl delete storageclass standard
    docker_exec kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml
}

install_tiller() {
    echo &#39;Installing Tiller...&#39;
    docker_exec kubectl --namespace kube-system create sa tiller
    docker_exec kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
    docker_exec helm init --service-account tiller --upgrade --wait
    echo
}

install_charts() {
    docker_exec ct install
    echo
}

main() {
    run_ct_container
    trap cleanup EXIT

    changed=$(docker_exec ct list-changed)
    if [[ -z &amp;quot;$changed&amp;quot; ]]; then
        echo &#39;No chart changes detected.&#39;
        return
    fi

    echo &#39;Chart changes detected.&#39;
    create_kind_cluster
    install_local_path_provisioner
    install_tiller
    install_charts
}

main
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;commit-the-changes&#34;&gt;Commit the changes&lt;/h3&gt;

&lt;p&gt;Next up commit these new changes to your master branch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add .
$ git commit -m &#39;add chart testing on PRs&#39;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-the-new-automation&#34;&gt;Test the new Automation&lt;/h2&gt;

&lt;p&gt;Create a new branch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout -b update-app2-chart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify the app2 &lt;code&gt;Chart.yaml&lt;/code&gt; to be a new version number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
appVersion: &amp;quot;1.0&amp;quot;
description: A Helm chart for Kubernetes
name: app2
version: 0.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commit and Push the changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add charts/app2/Chart.yaml
$ git commit -m &#39;bump chart2 version&#39;
$ git push origin update-app2-chart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Circle CI should run tests and should fail:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;circle-test-fail.png&#34; alt=&#34;circle fail test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This failure is because when &lt;code&gt;helm create&lt;/code&gt; creates your chart, it doesn&amp;rsquo;t implement all of our best practices. If you check in the Circle CI job log you&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Error validating data /root/project/charts/app2/Chart.yaml with schema /etc/ct/chart_schema.yaml
  home: Required field missing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The error is quite clear, we should have a field &lt;code&gt;home&lt;/code&gt; in our &lt;code&gt;Chart.yaml&lt;/code&gt;. In fact there should also be a &lt;code&gt;maintainers&lt;/code&gt; field. Let&amp;rsquo;s add those into both chart&amp;rsquo;s &lt;code&gt;Chart.yaml&lt;/code&gt; files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;home: http://github.com/paulczar/my-helm-charts
maintainers:
  - name: paulczar
    email: username.taken@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Since you&amp;rsquo;re also changing App1, you should bump its version a patch level to &lt;code&gt;0.1.2&lt;/code&gt;, all changes to a Chart, even non functional one should bump the chart version.&lt;/p&gt;

&lt;p&gt;Note: Ensure you leave a blank line at the end of the &lt;code&gt;Chart.yaml&lt;/code&gt; file. I forgot to and had to resubmit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Push these new changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add .
$ git commit -m &#39;comply to chart best practices&#39;
$ git push origin update-app2-chart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few seconds you should see the new jobs start in CircleCI and this time all three tasks should complete successfully:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;circle-lint-and-install.png&#34; alt=&#34;circle ci lint and install&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It took about 6 minutes to run, because it did a full install of both Charts (as we changed them both) to a disposable KIND cluster.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Since this was a branch, the charts were not released to the Chart Repository as that job is only triggered on the &lt;code&gt;master branch&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Next you&amp;rsquo;ll want to create a pull request for this change, you can do that via the &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; web ui:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;github-pull-request.png&#34; alt=&#34;github pull request&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Since Circle CI has already tested the commits in this PR (Pull Request) it shows handy little test pass/fail marks against the commits.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since the PR is showing as passing tests, you can go ahead and Merge it by clicking that green &lt;code&gt;Merge&lt;/code&gt; button (although I like to use &lt;code&gt;Squash and Merge&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;This Merge into the &lt;code&gt;master&lt;/code&gt; branch will kick off the &lt;code&gt;release-charts&lt;/code&gt; workflow and after a few seconds we&amp;rsquo;ll have an updated &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Repository:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://tech.paulcz.net/my-helm-charts/index.yaml
apiVersion: v1
entries:
...
...
  app1:
    name: app1
    version: 0.1.2
...
...
  app2:
    name: app2
    version: 0.1.1
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-pull-requests&#34;&gt;Testing Pull Requests&lt;/h2&gt;

&lt;p&gt;In the advanced settings of Circle CI you can tell it to automatically test Pull Requests that come from forks of your &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; repository. Adding this is a great feature if you want others to work on your code with you. However you do need to protect your secrets.&lt;/p&gt;

&lt;p&gt;For example a bad actor could add &amp;ldquo;echo $CH_TOKEN&amp;rdquo; to one of the scripts and steal my &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; token which they could then use to mess with my Repositories.&lt;/p&gt;

&lt;p&gt;For that reason I&amp;rsquo;ve opted not to include that in this example.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-1&#34;&gt;Part 1&lt;/a&gt; we created set of &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Charts managed in source control (GitHub).&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://tech.paulcz.net/blog/creating-a-helm-chart-monorepo-part-2&#34;&gt;Part 2&lt;/a&gt; we added automation via CircleCI to automate building and deploying Chart packages to a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart Repository hosted in &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Pages and &lt;a href=&#34;https://github.com&#34;&gt;GitHub&lt;/a&gt; Releases.&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;Part 3&lt;/strong&gt; we added further automation to test changes in those &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; charts and to pass them through rigorous testing before allowing them to be merged into the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Spring into Kubernetes - Deploying with Helm</title>
      <link>https://tech.paulcz.net/blog/spring-into-kubernetes-part-2/</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/spring-into-kubernetes-part-2/</guid>
      <description>Introduction In this installment of Spring into Kubernetes we&amp;rsquo;ll be looking at using Helm to install our Spring application to Kubernetes.
About Helm Helm is the package manager for Kubernetes. It provides tooling to create, template, package, and share Kubernetes manifests. A helm chart is effectively a signed tarball that contains a set of templated Kubernetes manifests, a metadata file and a set of default values.
Helm has two major components, the Helm client and the Tiller server.</description>
      <content>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In this installment of Spring into Kubernetes we&amp;rsquo;ll be looking at using &lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; to install our Spring application to Kubernetes.&lt;/p&gt;

&lt;h1 id=&#34;about-helm&#34;&gt;About Helm&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; is the package manager for Kubernetes. It provides tooling to create, template, package, and &lt;a href=&#34;https://hub.helm.sh/&#34;&gt;share&lt;/a&gt; Kubernetes manifests. A helm chart is effectively a signed tarball that contains a set of templated Kubernetes manifests, a metadata file and a set of default values.&lt;/p&gt;

&lt;p&gt;Helm has two major components, the Helm client and the Tiller server. The Helm client is a CLI tool that you use to create, package and deploy helm charts. The Tiller server is installed into your Kubernetes cluster and is responsible for managing the lifecycle of your applications as instructed by the Helm client.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: The Tiller server was created before Kubernetes extensions existed and will be removed in Helm 3 in favor of utilizing Kubernetes extensions. You can also use &amp;ldquo;tillerless&amp;rdquo; Helm but that&amp;rsquo;s out of scope for this blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Helm charts can be shared via a Helm Repository which gives you an easy way to upload, share, and download packages from a central location. The public &lt;a href=&#34;https://hub.helm.sh/&#34;&gt;Helm Hub&lt;/a&gt; has prebuilt Helm packages for most common open source applications.&lt;/p&gt;

&lt;h1 id=&#34;step-1-install-helm&#34;&gt;Step 1 - Install Helm&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.helm.sh/using_helm/#installing-helm&#34;&gt;Installing Helm&lt;/a&gt; is quite simple, if you&amp;rsquo;re on a Mac you can install Helm via Homebrew, otherwise check the &lt;a href=&#34;https://docs.helm.sh/using_helm/#installing-helm&#34;&gt;Helm install documentation&lt;/a&gt; for platform specific instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;brew install kubernetes-helm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the Helm client installed you can install the Tiller server to your Kubernetes cluster.&lt;/p&gt;

&lt;p&gt;If you are using minikube or a single tenant Kubernetes cluster without Role Based Authentication Control (RBAC) enabled you can deploy Tiller by simply running &lt;code&gt;helm init&lt;/code&gt;. On most clusters you should create a service account and role binding first like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;kubectl -n kube-system create serviceaccount tiller
kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
helm init --service-account=tiller
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a minute or so you can check it has finished installing by running &lt;code&gt;helm version&lt;/code&gt; which will give you the version of both the client and the server. If the server doesn&amp;rsquo;t respond just want a few more moments and try again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm version
Client: &amp;amp;version.Version{SemVer:&amp;quot;v2.12.2&amp;quot;, GitCommit:&amp;quot;7d2b0c73d734f6586ed222a567c5d103fed435be&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
Server: &amp;amp;version.Version{SemVer:&amp;quot;v2.12.2&amp;quot;, GitCommit:&amp;quot;7d2b0c73d734f6586ed222a567c5d103fed435be&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;step-2-create-and-deploy-a-new-helm-chart&#34;&gt;Step 2 - Create and Deploy a new Helm Chart&lt;/h1&gt;

&lt;p&gt;Use the Helm client to create a new Helm chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm create petclinic
Creating petclinic

$ cd petclinic

$ tree
├── charts
├── Chart.yaml
├── templates
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── ingress.yaml
│   ├── NOTES.txt
│   ├── service.yaml
│   └── tests
│       └── test-connection.yaml
└── values.yaml

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the Helm chart sets up a boilerplate Helm chart to get you started. This is actually a fully functioning chart so you can go ahead and deploy it right away to ensure that everything is working correctly. You could simply run &lt;code&gt;helm install .&lt;/code&gt; but generally you&amp;rsquo;ll want to specify a namespace and release name by using the &lt;code&gt;--namespace&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; for better management.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm install --namespace test --name test .
NAME:   test
LAST DEPLOYED: Tue Feb  5 06:26:19 2019
NAMESPACE: test
STATUS: DEPLOYED
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;code&gt;kubectl port-forward&lt;/code&gt; to test that everything worked right:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl --namespace test port-forward deployment/test-petclinic 8080:80
Visit http://127.0.0.1:8080 to use your application
Forwarding from [::1]:8080 -&amp;gt; 80
Forwarding from 127.0.0.1:8080 -&amp;gt; 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point your browser at &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt; and you should see the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./welcome-nginx.png&#34; alt=&#34;Nginx Welcome Screen&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But this isn&amp;rsquo;t Petclinic it&amp;rsquo;s an empty nginx container. Since our petclinic app is pretty simple we can use this boilerplate chart to deploy Petclinic with just a few minor changes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The nginx app inside the container listens on port 80, petclinic listens on port 8080 so you&amp;rsquo;ll need to edit the file &lt;code&gt;templates/deployment.yaml&lt;/code&gt; and find the YAML &lt;code&gt;containerPort: 80&lt;/code&gt; under the container spec and change the value to &lt;code&gt;8080&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Also in the &lt;code&gt;templates/deployment.yaml&lt;/code&gt; file you want to increase the initial timeout for the &lt;code&gt;livenessCheck&lt;/code&gt; check as Java takes longer to be ready than nginx. Find the YAML key &lt;code&gt;livenessProbe:&lt;/code&gt; and add the keypair &lt;code&gt;initialDelaySeconds: 60&lt;/code&gt; to it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The updated section of the &lt;code&gt;templates/deployment.yaml&lt;/code&gt; should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: &amp;quot;{{ .Values.image.repository }}:{{ .Values.image.tag }}&amp;quot;
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          livenessProbe:
            initialDelaySeconds: 60
            httpGet:
              path: /
              port: http

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: the double curly brace &lt;code&gt;{{ }}&lt;/code&gt; signifies for the golang templating engine to process some code, usually print out some values, but can also be used for if/then statements and loops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You also need to set the image and tag to petclinic. You could edit &lt;code&gt;values.yaml&lt;/code&gt; to change the defaults, but you can also override default values with &lt;code&gt;--set&lt;/code&gt;. Since we&amp;rsquo;ve already deployed the helm chart we can &lt;em&gt;upgrade&lt;/em&gt; it by running a &lt;code&gt;helm upgrade&lt;/code&gt; and providing the appropriate &lt;code&gt;--set&lt;/code&gt; flag like so:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: &lt;code&gt;helm upgrade&lt;/code&gt; helps you to manage the release lifecycle of your application, Tiller keeps track of the releases that you&amp;rsquo;ve deployed and helps you both upgrade and rollback deployments.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm upgrade test \
  --set image.repository=paulczar/spring-petclinic \
  --set image.tag=latest .
Release &amp;quot;test&amp;quot; has been upgraded. Happy Helming!
LAST DEPLOYED: Tue Feb  5 06:54:07 2019
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Forward port 8080 through to the deployment again and check its working via your web browser:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: the command shown in the &lt;code&gt;helm upgrade&lt;/code&gt; output is wrong because we&amp;rsquo;re using port 8080 now, you could fix the output by editing the file &lt;code&gt;templates/NOTES.txt&lt;/code&gt;, but for now just run the command below.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ kubectl --namespace test port-forward deployment/test-petclinic 8080
Forwarding from [::1]:8080 -&amp;gt; 8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./pc-localhost.png&#34; alt=&#34;petclinic&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;step-3-cleanup&#34;&gt;Step 3 - Cleanup&lt;/h1&gt;

&lt;p&gt;To uninstall the helm chart simple run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm delete --purge test
release &amp;quot;test&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;step-4-optional-package-your-helm-chart&#34;&gt;Step 4 (optional) - Package your Helm Chart&lt;/h1&gt;

&lt;p&gt;Helm charts are designed to be packaged and shared via a Helm repository. Simply running &lt;code&gt;helm package .&lt;/code&gt; will create the Helm package like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mkdir pkg
$ helm package -d pkg .
Successfully packaged chart and saved it to: /tmp/petclinic/petclinic-0.1.0.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These packages combined with an index file can be hosted on any static website (github pages is very common) to create a Helm Repository. You can generate the index file with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo index pkg
$ cat pkg/index.yaml
apiVersion: v1
entries:
  petclinic:
  - apiVersion: v1
    appVersion: &amp;quot;1.0&amp;quot;
    created: 2019-02-06T02:45:10.99990157-06:00
    description: A Helm chart for Kubernetes
    digest: 86f3740e6bc325ea330428e42af091d6613ca9b92678b3aecdf680f0302b4685
    name: petclinic
    urls:
    - petclinic-0.1.0.tgz
    version: 0.1.0
generated: 2019-02-06T02:45:10.99955354-06:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use any basic web server as a Helm repository, many folks are using &lt;a href=&#34;https://github.com/int128/helm-github-pages&#34;&gt;github pages&lt;/a&gt; which is quite a clever way to host your Helm Repository right next to the actual code for your Helm chart.&lt;/p&gt;

&lt;h1 id=&#34;step-5-use-a-helm-repository&#34;&gt;Step 5 - Use a Helm Repository&lt;/h1&gt;

&lt;p&gt;I have created a more featureful Helm Chart designed specifically to generically run most Spring applications which can be found on my github repo &lt;a href=&#34;https://github.com/paulczar/helm-chart-spring&#34;&gt;helm-chart-spring&lt;/a&gt;. It installs petclinic by default and has options to be able to automatically set up LoadBalancers and Ingress as well as more advanced kubernetes resources such as &lt;code&gt;podDisruptionBudgets&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can install it straight from my Helm Repository like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo add paulczar http://tech.paulcz.net/helm-chart-spring/repo
&amp;quot;paulczar&amp;quot; has been added to your repositories

$ helm install --namespace test --name test \
    paulczar/spring --set service.type=LoadBalancer \
    --version 0.0.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few moments you should be able to access the petclinic app via the LoadBalancer created by the above command.  Run &lt;code&gt;kubectl get svc&lt;/code&gt; to find the IP:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ k get svc
NAME          TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)        AGE
test-spring   LoadBalancer   10.100.200.137   35.238.37.241   80:30509/TCP   89s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point your browser at the &lt;code&gt;EXTERNAL-IP&lt;/code&gt; value:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./kube-lb-pc.png&#34; alt=&#34;petclinic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Uninstall the Helm chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm delete --purge test
release &amp;quot;test&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;Helm has made it incredibly easy to get started creating and customizing charts to install Applications on Kubernetes. By templating and packaging your Kubernetes manifests you get an easy to share package for your application and are able to enable a lot of deployment flexibility to deploy multiple releases of your application to one or many Kubernetes clusters and customize things like the service type giving you tremendous control over how people access it.&lt;/p&gt;

&lt;p&gt;Better yet, if you are looking to install an open source application you should first look to the &lt;a href=&#34;https://hub.helm.sh/&#34;&gt;Helm Hub&lt;/a&gt; which is a public repository of hundreds of pre-packaged helm charts that install with just a few keypresses.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Writing Your First Helm Chart</title>
      <link>https://tech.paulcz.net/blog/getting-started-with-helm/</link>
      <pubDate>Tue, 03 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://tech.paulcz.net/blog/getting-started-with-helm/</guid>
      <description>I recently found myself writing instructions on how to deploy an application to several Kubernetes platform and ended up writing a different Kubernetes manifests for each platform. 95% of the content was the same with just a few different directives based on how the particular platform handles ingress, or if we needed a Registry secret or a TLS certificate.
Kubernetes manifests are very declarative and don&amp;rsquo;t offer any way to put conditionals or variables that could be set in them.</description>
      <content>

&lt;p&gt;I recently found myself writing &lt;a href=&#34;https://github.com/IBM/activator-lagom-java-chirper/blob/master/docs/README.md&#34;&gt;instructions&lt;/a&gt; on how to deploy an
application to several Kubernetes platform and ended up writing a different Kubernetes manifests for each
platform. 95% of the content was the same with just a few different directives
based on how the particular platform handles ingress, or if we needed a Registry secret or a TLS certificate.&lt;/p&gt;

&lt;p&gt;Kubernetes manifests are very declarative and don&amp;rsquo;t offer any way to put conditionals or variables that could be set in them. This
is both a good and a bad thing. Enter &lt;a href=&#34;https://docs.helm.sh/&#34;&gt;Helm&lt;/a&gt; a Package Manager for Kubernetes. Helm allows you to package up
your Kubernetes application as a package that can be deployed easily to Kubernetes, One of its features (and the one that interested me)
the ability to template out your Kubernetes manifests.&lt;/p&gt;

&lt;p&gt;If you already have a Kubernetes manifest its very easy to turn it into a Helm Chart that you can then
iterate over and improve as you need to add more flexibility to it. In fact your first iteration of a
Helm chart can be as simple as moving your manifests into a new directory and adding a few lines
to a Chart.yaml file.&lt;/p&gt;

&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll need the following installed to follow along with this tutorial:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube/&#34;&gt;Minikube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/docs/install.md&#34;&gt;Helm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/&#34;&gt;kubectl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;prepare-environment&#34;&gt;Prepare Environment&lt;/h2&gt;

&lt;p&gt;Bring up a test Kubernetes environment using Minikube:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ minikube start
Starting local Kubernetes v1.7.5 cluster...
Starting VM...
Getting VM IP address...
Moving files into cluster...
Setting up certs...
Connecting to cluster...
Setting up kubeconfig...
Starting cluster components...
Kubectl is now configured to use the cluster.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait a minute or so and install Helm&amp;rsquo;s tiller service to Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm init
$HELM_HOME has been configured at /home/pczarkowski/.helm.

Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.
Happy Helming!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a path to work in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir -p ~/development/my-first-helm-chart
$ cd ~/development/my-first-helm-chart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;If it fails out you may need to wait a few more minutes for minikube to become
accessible.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;create-example-kubernetes-manifest&#34;&gt;Create Example Kubernetes Manifest.&lt;/h2&gt;

&lt;p&gt;Writing a Helm Chart is easier when you&amp;rsquo;re starting with an existing set of
Kubernetes manifests. One of the easiest ways to get a basic working manifest
is to ask Kubernetes to
&lt;a href=&#34;https://blog.heptio.com/using-kubectl-to-jumpstart-a-yaml-file-heptioprotip-6f5b8a63a3ea&#34;&gt;run something and then fetch the manifest&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir manifests
$ kubectl run example --image=nginx:1.13.5-alpine \
    -o yaml &amp;gt; manifests/deployment.yaml
$ kubectl expose deployment example --port=80 --type=NodePort \
    -o yaml &amp;gt; manifests/service.yaml
$ minikube service example --url       
http://192.168.99.100:30254
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All going well you should be able to hit the provided URL and get the &amp;ldquo;Welcome to nginx!&amp;rdquo;
page. You&amp;rsquo;ll see you now have two Kubernetes manifests saved. We can use these
to bootstrap our helm charts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree manifests
manifests
├── deployment.yaml
└── service.yaml
0 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we move on we should clean up our environment.  We can use the newly
created manifests to help:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl delete -f manifests
deployment &amp;quot;example&amp;quot; deleted
service &amp;quot;example&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-and-deploy-a-basic-helm-chart&#34;&gt;Create and Deploy a Basic Helm Chart&lt;/h2&gt;

&lt;p&gt;Helm has some tooling to create the scaffolding needed to start developing a
new Helm Chart. We&amp;rsquo;ll create it with a placeholder name of &lt;code&gt;helm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm create helm
Creating helm
tree helm
helm
├── charts
├── Chart.yaml
├── templates
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── ingress.yaml
│   ├── NOTES.txt
│   └── service.yaml
└── values.yaml
2 directories, 7 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helm will have created a number of files and directories.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Chart.yaml&lt;/code&gt; - the metadata for your Helm Chart.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;values.yaml&lt;/code&gt; - values that can be used as variables in your templates.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;templates/*.yaml&lt;/code&gt; - Example Kubernetes manifests.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_helpers.tpl&lt;/code&gt; - helper functions that can be used inside the templates.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;templates/NOTES.txt&lt;/code&gt; - templated notes that are displayed on Chart install.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Edit &lt;code&gt;Chart.yaml&lt;/code&gt; so that it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
description: My First Helm Chart - NGINX Example
name: my-first-helm-chart
version: 0.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy our example Kubernetes manifests over the provided templates and remove the
currently unused &lt;code&gt;ingress.yaml&lt;/code&gt; and &lt;code&gt;NOTES.txt&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp manifests/* helm/templates/
$ rm helm/templates/ingress.yaml
$ rm helm/templates/NOTES.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we should be able to install our helm chart which will deploy our application
to Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm install -n my-first-helm-chart helm
NAME:   my-first-helm-chart
LAST DEPLOYED: Tue Oct  3 10:20:57 2017
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Service
NAME     CLUSTER-IP  EXTERNAL-IP  PORT(S)       AGE
example  10.0.0.210  &amp;lt;nodes&amp;gt;      80:30254/TCP  0s

==&amp;gt; v1beta1/Deployment
NAME     DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
example  1        1        1           0          0s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Like before we can use &lt;code&gt;minikube&lt;/code&gt; to get the URL:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ minikube service example --url    
http://192.168.99.100:30254
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again accessing that URL via your we browser should get you the default NGINX welcome page.&lt;/p&gt;

&lt;p&gt;Congratulations!  You&amp;rsquo;ve just created and deployed your first Helm chart. However we&amp;rsquo;re
not quite done yet. use Helm to delete your deployment and then lets move on to customizing
the Helm Chart with variables and values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm del --purge my-first-helm-chart
release &amp;quot;my-first-helm-chart&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;add-variables-to-your-helm-chart&#34;&gt;Add variables to your Helm Chart&lt;/h2&gt;

&lt;p&gt;Check out &lt;code&gt;helm/values.yaml&lt;/code&gt; and you&amp;rsquo;ll see there&amp;rsquo;s a lot of variables already
defined by the example that helm provided when you created the helm chart. You&amp;rsquo;ll
notice that it is has values for &lt;code&gt;nginx&lt;/code&gt; in there. This is because Helm also uses
nginx as their example. We can re-use some of the values provided but we should clean
it up a bit.&lt;/p&gt;

&lt;p&gt;Edit &lt;code&gt;helm/values.yaml&lt;/code&gt; to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;replicaCount: 1
image:
  repository: nginx
  tag: 1.13.5-alpine
  pullPolicy: IfNotPresent
  pullSecret:
service:
  type: NodePort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can access any of these values in our templates using the golang templating
engine. For example accessing &lt;code&gt;replicaCount&lt;/code&gt; would be written as &lt;code&gt;{{ .Values.replicaCount }}&lt;/code&gt;.
Helm also provides information about the Chart and Release which we&amp;rsquo;ll also utilize.&lt;/p&gt;

&lt;p&gt;Update your &lt;code&gt;helm/templates/deployment.yaml&lt;/code&gt; to utilize our values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1beta1
kind: Deployment
metadata:
  creationTimestamp: 2017-10-03T15:03:17Z
  generation: 1
  labels:
    run: &amp;quot;{{ .Release.Name }}&amp;quot;
    chart: &amp;quot;{{ .Chart.Name }}-{{ .Chart.Version }}&amp;quot;
    release: &amp;quot;{{ .Release.Name }}&amp;quot;
    heritage: &amp;quot;{{ .Release.Service }}&amp;quot;     
  name: &amp;quot;{{ .Release.Name }}&amp;quot;
  namespace: default
  resourceVersion: &amp;quot;3030&amp;quot;
  selfLink: /apis/extensions/v1beta1/namespaces/default/deployments/example
  uid: fd03ac95-a84b-11e7-a417-0800277e13b3
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      run: &amp;quot;{{ .Release.Name }}&amp;quot;
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        run: &amp;quot;{{ .Release.Name }}&amp;quot;
    spec:
      {{- if .Values.image.pullSecret }}    
            imagePullSecrets:
              - name: &amp;quot;{{ .Values.image.pullSecret }}&amp;quot;
      {{- end }}          
      containers:
      - image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        name: example
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
status: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note the use of the &lt;code&gt;if&lt;/code&gt; statement around &lt;code&gt;image.pullSecret&lt;/code&gt; being set. This
sort of conditional becomes very important when making your Helm Chart portable across
different Kubernetes platforms.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Next edit your &lt;code&gt;helm/templates/service.yaml&lt;/code&gt; to look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  creationTimestamp: 2017-10-03T15:03:30Z
  labels:
    run: &amp;quot;{{ .Release.Name }}&amp;quot;
    chart: &amp;quot;{{ .Chart.Name }}-{{ .Chart.Version }}&amp;quot;
    release: &amp;quot;{{ .Release.Name }}&amp;quot;
    heritage: &amp;quot;{{ .Release.Service }}&amp;quot;  
  name: &amp;quot;{{ .Release.Name }}&amp;quot;
  namespace: default
  resourceVersion: &amp;quot;3066&amp;quot;
  selfLink: /api/v1/namespaces/default/services/example
  uid: 044d2b7e-a84c-11e7-a417-0800277e13b3
spec:
  clusterIP:
  externalTrafficPolicy: Cluster
  ports:
  - nodePort: 30254
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    run: &amp;quot;{{ .Release.Name }}&amp;quot;
  sessionAffinity: None
  type: &amp;quot;{{ .Values.service.type }}&amp;quot;
status:
  loadBalancer: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once your files are written out you should be able to install the Helm Chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm install -n second helm
NAME:   second
LAST DEPLOYED: Tue Oct  3 10:59:41 2017
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Service
NAME    CLUSTER-IP  EXTERNAL-IP  PORT(S)       AGE
second  10.0.0.160  &amp;lt;nodes&amp;gt;      80:30254/TCP  1s

==&amp;gt; v1beta1/Deployment
NAME    DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
second  1        1        1           0          1s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next use minikube to get the URL of the service, but since we templated the
service name to match the release you&amp;rsquo;ll want to use this new name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ minikube service second --url
http://192.168.99.100:30254
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets try something fun. Change the image we&amp;rsquo;re using by upgrading the helm release
and overriding some values on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm upgrade --set image.repository=httpd --set image.tag=2.2.34-alpine second helm
Release &amp;quot;second&amp;quot; has been upgraded. Happy Helming!
LAST DEPLOYED: Tue Oct  3 11:09:30 2017
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Service
NAME    CLUSTER-IP  EXTERNAL-IP  PORT(S)       AGE
second  10.0.0.160  &amp;lt;nodes&amp;gt;      80:30254/TCP  9m

==&amp;gt; v1beta1/Deployment
NAME    DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
second  1        1        1           0          9m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then go to our minikube provided URL and you&amp;rsquo;ll see a different message &lt;code&gt;It works!&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;clean-up&#34;&gt;Clean up&lt;/h2&gt;

&lt;p&gt;use &lt;code&gt;minikube delete&lt;/code&gt; to clean up your environment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;minikube delete
Deleting local Kubernetes cluster...
Machine deleted.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Helm is a very powerful way to package up your Kubernetes manifests to make them
extensible and portable. While it is quite complicated its fairly easy to get started
with it and if you&amp;rsquo;re like me you&amp;rsquo;ll find yourself replacing the Kubernetes manifests
in your code repos with Helm Charts.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot more you can do with Helm, we&amp;rsquo;ve just scratched the surface. Enjoy
using and learning more about them!&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>